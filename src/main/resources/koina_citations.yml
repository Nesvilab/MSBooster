openapi: 3.0.3
info:
  title: Koina - Getting started
  description: |-
    Models can be accessed through various programming languages and tools. The easiest way to access models is by using the **Try button** available on this website for each model. Clicking this button sends the example input found in the documentation to the model and returns the result. You can modify the input data and view the results directly in your browser. When predicting fragment ion intensities, the resulting spectra are visualized in the browser.

    To compare predictions of different models or against experimental spectra accessible via the Universal Spectrum Identifier (USI), visit the [Compare Spectra Tab](/compare-spectra).

    Each model's documentation includes several ready-to-use code samples for different programming languages, enabling you to quickly integrate with Koina. If you develop a new integration with Koina not covered by the provided samples, please consider contributing your code to the Koina GitHub repository.

    Additionally, several popular proteomics tools have integrated Koina into their software, such as [FragPipe](https://fragpipe.nesvilab.org/docs/tutorial_koina.html), [Skyline](https://skyline.ms/project/home/software/skyline/begin.view), and [Oktoberfest](https://oktoberfest.readthedocs.io/en/stable/).

    If you use Koina in your research, either directly or through one of its available integrations, **please cite the model you used as well as the following paper:**

    ```
    Koina: Democratizing machine learning for proteomics research  
    Ludwig Lautenbacher, Kevin L. Yang, Tobias Kockmann, et al.  
    bioRxiv 2024.06.01.596953; doi: https://doi.org/10.1101/2024.06.01.596953
    ```
  version: 0.0.1
  contact:
    email: Ludwig.Lautenbacher@tum.de
externalDocs:
  description: Koina GitHub
  url: https://github.com/wilhelm-lab/koina
servers:
  - url: https://koina.wilhelmlab.org/v2/models
tags: # Define order of Tags
  - name: Fragment intensity
  - name: Retention Time
  - name: Collisional cross section
  - name: Cross-linking fragment intensity
  - name: Metabolomics fragment intensity
paths:

  /3dmolms_orbitrap/infer:
     post:
      tags:
        - Metabolomics fragment intensity
      summary: 3dmolms_orbitrap
      description: |
        ### Summary
        The 3DMolMS model is a deep neural network that predicts tandem mass spectrometry (MS/MS) spectra from the 3D conformations of chemical compounds. The goal of the model is to improve compound identification in untargeted metabolomics.<br>The 3DMolMS model consists of an encoder and a decoder. The encoder takes as input a point set representation of the 3D conformation of a compound. This point set is generated by using the ETKDG algorithm to generate a 3D conformer of the compound and then encoding each atom in the conformer as a point. Each point is represented by a vector of 21 dimensions, which includes the x, y, and z coordinates of the atom, as well as a number of other attributes, such as the atom type, the number of neighbors, and the atomic mass. The encoder then uses six 3DMolConv-based hidden layers to extract features from the input point set. The decoder takes the output of the encoder and uses five fully connected layers to predict the MS/MS spectrum of the compound.<br>**Data**<br>Source of Data: The model was trained using approximately 70,000 MS/MS spectra from the Agilent Personal Compound Database and Library (PCDL) and the NIST20 spectral library.<br>Type of Molecules: The training data covers a broad range of chemical compounds relevant to untargeted metabolomics. This is not limited to a single class but includes a diverse set of metabolites typically encountered in metabolomics studies.<br>Representation of Molecular Complexity: The training set is drawn from libraries that contain spectra from a large number of compounds, suggesting that it covers a broad spectrum of molecular diversity. However, because these spectra were acquired under similar instrument conditions, the training data might not fully capture the variability and complexity seen in real-world experiments that use different instruments or settings.<br>Limitations of Training Data: Since the training spectra come from libraries with similar instrument settings, the model may be less robust when applied to data acquired under different conditions or using different instruments. While the training set covers a wide range of metabolites, any biases in the library composition could still limit performance on underrepresented molecular classes.<br>**Optimization**<br>Optimization Target: 3DMolMS is optimized to predict the complete MS/MS spectrum of a compound. The training procedure minimizes the cosine distance (i.e., maximizes cosine similarity) between the predicted and experimental spectra.<br>Metric: Cosine Similarity<br>**Model**<br>Interpretability: 3DMolMS is a black box.<br>Model insights:  The latent features learned by the model are not only useful for predicting MS/MS spectra but have also been successfully transferred to predict other chemical properties like retention time (RT) and collision cross section (CCS) suggesting that the model captures meaningful chemical information.<br>Model Type: Regression model. It outputs a continuous 1D spectral vector where each of the 7500 dimensions represents the transformed intensity<br>Limitations: Fixed spectral resolution parameters.<br>**Evaluation**<br>Performance Measures: The model was evaluated using cosine similarity between the predicted and experimental spectra.<br>Reason for Performance Measures: Metric Justification: Cosine similarity is chosen for its ability to capture spectral shape and relative intensities.<br>Model Evaluation: The model was evaluated on spectra from the same libraries (PCDL and NIST20) as well as on an independent test set from the MassBank of North America (MoNA) library. The MoNA library contains spectra acquired from a variety of Q-TOF instruments, allowing for evaluation of the model’s generalizability to different instruments.<br>Data Applicability: Optimized for small molecule MS/MS spectra within a fixed m/z range and specific pre-processing; performance may vary with different experimental setups.<br>**Input notes**<br>Supported precursor types are `["[M+H]+", "[M-H]-", "[M+H-H2O]+", "[M+Na]+", "[M+2H]2+"]`.<br>Max number of atoms in the input molecule is 100 and min is 10.<br>supported atoms are `["C", "O", "N", "H", "P", "S", "F", "Cl", "B", "Br", "I"]`<br>**Output notes**<br>The intensity result is normalized to the highest predicted intensity value in the spectrum (i.e., the maximum intensity is set to 1).<br>The output has the resolution of 0.2 Da for the m/z range of 0-1500 Da (7500 bins).<br>

        ### Citation
        3DMolMS: prediction of tandem mass spectra from 3D molecular conformations, <br>Yuhui Hong, Sujun Li, Christopher J Welch, Shane Tichy, Yuzhen Ye, Haixu Tang, <br>Bioinformatics, Volume 39, Issue 6, June 2023, btad354, https://doi.org/10.1093/bioinformatics/btad354<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['smiles'] = np.array(["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]) 
            inputs['precursor_types'] = np.array(["[M+H]+"]) 
            inputs['collision_energies'] = np.array([20])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("3dmolms_orbitrap", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/3dmolms_orbitrap/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "smiles", "shape": [1,1], "datatype": "BYTES", "data": ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]},
                        {"name": "precursor_types", "shape": [1,1], "datatype": "BYTES", "data": ["[M+H]+"]},
                        {"name": "collision_energies", "shape": [1,1], "datatype": "FP32", "data": [20]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/3dmolms_orbitrap/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "smiles", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")),
                    list("name"= "precursor_types", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("[M+H]+")),
                    list("name"= "collision_energies", "shape"= c(1,1), "datatype"= "FP32", "data"= c(20)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "3dmolms_orbitrap",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("smiles" = c("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")),
                list("precursor_types" = c("[M+H]+")),
                list("collision_energies" = c(20)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/3dmolms_orbitrap/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "smiles", "shape": [1,1], "datatype": "BYTES", "data": ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]},
                                {"name": "precursor_types", "shape": [1,1], "datatype": "BYTES", "data": ["[M+H]+"]},
                                {"name": "collision_energies", "shape": [1,1], "datatype": "FP32", "data": [20]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/3dmolms_orbitrap/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"smiles\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_types\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"[M+H]+\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [1,1], \"datatype\": \"FP32\", \"data\": [20]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: 3dmolms_orbitrap
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/3dmolms_orbitrap_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /3dmolms_qtof/infer:
     post:
      tags:
        - Metabolomics fragment intensity
      summary: 3dmolms_qtof
      description: |
        ### Summary
        The 3DMolMS model is a deep neural network that predicts tandem mass spectrometry (MS/MS) spectra from the 3D conformations of chemical compounds. The goal of the model is to improve compound identification in untargeted metabolomics.<br>The 3DMolMS model consists of an encoder and a decoder. The encoder takes as input a point set representation of the 3D conformation of a compound. This point set is generated by using the ETKDG algorithm to generate a 3D conformer of the compound and then encoding each atom in the conformer as a point. Each point is represented by a vector of 21 dimensions, which includes the x, y, and z coordinates of the atom, as well as a number of other attributes, such as the atom type, the number of neighbors, and the atomic mass. The encoder then uses six 3DMolConv-based hidden layers to extract features from the input point set. The decoder takes the output of the encoder and uses five fully connected layers to predict the MS/MS spectrum of the compound.<br>**Data**<br>Source of Data: The model was trained using approximately 70,000 MS/MS spectra from the Agilent Personal Compound Database and Library (PCDL) and the NIST20 spectral library.<br>Type of Molecules: The training data covers a broad range of chemical compounds relevant to untargeted metabolomics. This is not limited to a single class but includes a diverse set of metabolites typically encountered in metabolomics studies.<br>Representation of Molecular Complexity: The training set is drawn from libraries that contain spectra from a large number of compounds, suggesting that it covers a broad spectrum of molecular diversity. However, because these spectra were acquired under similar instrument conditions, the training data might not fully capture the variability and complexity seen in real-world experiments that use different instruments or settings.<br>Limitations of Training Data: Since the training spectra come from libraries with similar instrument settings, the model may be less robust when applied to data acquired under different conditions or using different instruments. While the training set covers a wide range of metabolites, any biases in the library composition could still limit performance on underrepresented molecular classes.<br>**Optimization**<br>Optimization Target: 3DMolMS is optimized to predict the complete MS/MS spectrum of a compound. The training procedure minimizes the cosine distance (i.e., maximizes cosine similarity) between the predicted and experimental spectra.<br>Metric: Cosine Similarity<br>**Model**<br>Interpretability: 3DMolMS is a black box.<br>Model insights:  The latent features learned by the model are not only useful for predicting MS/MS spectra but have also been successfully transferred to predict other chemical properties like retention time (RT) and collision cross section (CCS) suggesting that the model captures meaningful chemical information.<br>Model Type: Regression model. It outputs a continuous 1D spectral vector where each of the 7500 dimensions represents the transformed intensity<br>Limitations: Fixed spectral resolution parameters.<br>**Evaluation**<br>Performance Measures: The model was evaluated using cosine similarity between the predicted and experimental spectra.<br>Reason for Performance Measures: Metric Justification: Cosine similarity is chosen for its ability to capture spectral shape and relative intensities.<br>Model Evaluation: The model was evaluated on spectra from the same libraries (PCDL and NIST20) as well as on an independent test set from the MassBank of North America (MoNA) library. The MoNA library contains spectra acquired from a variety of Q-TOF instruments, allowing for evaluation of the model’s generalizability to different instruments.<br>Data Applicability: Optimized for small molecule MS/MS spectra within a fixed m/z range and specific pre-processing; performance may vary with different experimental setups.<br>**Input notes**<br>Supported precursor types are `["[M+H]+", "[M-H]-", "[M+H-H2O]+", "[M+Na]+", "[M+2H]2+"]`.<br>Max number of atoms in the input molecule is 100 and min is 10.<br>supported atoms are `["C", "O", "N", "H", "P", "S", "F", "Cl", "B", "Br", "I"]`<br>**Output notes**<br>The intensity result is normalized to the highest predicted intensity value in the spectrum (i.e., the maximum intensity is set to 1).<br>The output has the resolution of 0.2 Da for the m/z range of 0-1500 Da (7500 bins).<br>

        ### Citation
        3DMolMS: prediction of tandem mass spectra from 3D molecular conformations, <br>Yuhui Hong, Sujun Li, Christopher J Welch, Shane Tichy, Yuzhen Ye, Haixu Tang, <br>Bioinformatics, Volume 39, Issue 6, June 2023, btad354, https://doi.org/10.1093/bioinformatics/btad354<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['smiles'] = np.array(["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]) 
            inputs['precursor_types'] = np.array(["[M+H]+"]) 
            inputs['collision_energies'] = np.array([20])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("3dmolms_qtof", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/3dmolms_qtof/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "smiles", "shape": [1,1], "datatype": "BYTES", "data": ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]},
                        {"name": "precursor_types", "shape": [1,1], "datatype": "BYTES", "data": ["[M+H]+"]},
                        {"name": "collision_energies", "shape": [1,1], "datatype": "FP32", "data": [20]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/3dmolms_qtof/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "smiles", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")),
                    list("name"= "precursor_types", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("[M+H]+")),
                    list("name"= "collision_energies", "shape"= c(1,1), "datatype"= "FP32", "data"= c(20)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "3dmolms_qtof",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("smiles" = c("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")),
                list("precursor_types" = c("[M+H]+")),
                list("collision_energies" = c(20)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/3dmolms_qtof/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "smiles", "shape": [1,1], "datatype": "BYTES", "data": ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]},
                                {"name": "precursor_types", "shape": [1,1], "datatype": "BYTES", "data": ["[M+H]+"]},
                                {"name": "collision_energies", "shape": [1,1], "datatype": "FP32", "data": [20]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/3dmolms_qtof/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"smiles\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_types\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"[M+H]+\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [1,1], \"datatype\": \"FP32\", \"data\": [20]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: 3dmolms_qtof
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/3dmolms_qtof_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /AlphaPeptDeep_ccs_generic/infer:
     post:
      tags:
        - Collisional cross section
      summary: AlphaPeptDeep_ccs_generic
      description: |
        ### Summary
        **Data**<br>Source of Data: "Deep learning the collisional cross sections of the peptide universe from a million experimental values."<br>Type of Molecules: The training data includes tryptic, LysC and LysN peptides from HeLA including the modifications Oxidation@M, Carbamidomethyl@C and Acetyl@Protein N-term.<br>Representation of molecular complexity: The training data includes peptides from multiple organisms and the most commonly used PTMs in proteomics.<br>Data Acquisition: All training and testing data was acquired using TIMS-TOF Pro. An ion mobility range from 1/K0 = 1.51 to 0.6 Vs cm−2 using equal ion accumulation and ramp time in the dual TIMS analyzer of 100 ms each was analyzed.<br>Limitations of Training Data: While the model can attempt to predict for arbitrary PTMs it was only trained and evaluated with a limited set of PTMs.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization Target: Collissional cross section<br>Metric: Mean absolute error<br>**Model**<br>Interpretability: The model is a black box.<br>Model type: The model performs regression, predicting a continuous CCS value.<br>Limitations: The model has not been evaluate on data not from the timsTOF Pro.<br>**Evaluation**<br>Performance measures: Pearson correlation (R)<br>Choice of performance measures: Pearson correlation (R) is chosen to determine the linear correlation between predicted and experimental values.<br>Single number performance: R2 > 0.98<br>Comparison to Baseline Methods: The model was compared with the Prosit 2020 HCD model and showed similiar performance.<br>Evaluation methods: The model was evalutaed on E. coli  and Yeast peptides from the same data source as the training data.<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different peptides, and datasets.<br>Applicability: The model is applicable to the prediction of MS2 spectra for HLA peptides with different modifications.<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Supported any modification from UNIMOD. Cysteine residues should be carbamidomethylated (C[UNIMOD:4]). There is no limit to sequence length.<br>There are no limitations to valid Precursor Charges.<br>**Output notes**<br>

        ### Citation
        AlphaPeptDeep: a modular deep learning framework to predict peptide properties for proteomics.<br>Wen-Feng Zeng, Xie-Xuan Zhou, Sander Willems, Constantin Ammar, Maria Wahle, et al <br>Nat Commun 13, 7238 (2022). https://doi.org/10.1038/s41467-022-34904-3<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]) 
            inputs['precursor_charges'] = np.array([2,2])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("AlphaPeptDeep_ccs_generic", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ccs_generic/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2,2]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ccs_generic/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2,2)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "AlphaPeptDeep_ccs_generic",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                list("precursor_charges" = c(2,2)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ccs_generic/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2,2]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ccs_generic/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\", \"AAAAAKAKM\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2,2]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: AlphaPeptDeep_ccs_generic
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AlphaPeptDeep_ccs_generic_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /AlphaPeptDeep_ms2_generic/infer:
     post:
      tags:
        - Fragment intensity
      summary: AlphaPeptDeep_ms2_generic
      description: |
        ### Summary
        **Data**<br>Source of Data: The training and testing data were collected from various instruments and collisional energies, including ProteomeTools, which were derived from synthetic peptides with known ground truth. <br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN.<br>Representation of molecular complexity: The training data was designed to represent a wide variety of peptide sequences and fragmentation patterns, including both tryptic and non-tryptic peptides. The data included a large number of peptides with different amino acid combinations, covering nearly all possible N- and C-terminal amino acid combinations. This was done to address the challenge of identifying non-tryptic HLA peptides, whose fragmentation characteristics can be distinct from tryptic peptides.<br>Limitations of Training Data: While the model can attempt to predict for arbitrary PTMs it was only trained and evaluated with a limited set of PTMs.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: PCC90 between replicates is "somewhat less than 100%".<br>Metric: Mean absolute error<br>**Model**<br>Interpretability: The model is a black box.<br>Model Type: The model is a regression model, predicting the intensity of different fragment ions.<br>**Evaluation**<br>Performance Measures: Pearson correllation (PCC) and number of spectra with at least 90% PCC PCC90<br>Reason for Performance Measures: PCC is chosen as a measure to compare the similarity between the measured and the predicted MS2 spectra.<br>Single number performance: PCC90 97% on tryptic and LysC peptides 92% on HLA peptides.<br>Comparison to Baseline Methods: PCC90 of experimental variation <br>Model Evaluation: The model is evaluated on multiple datasets covering peptides from ProteomeTools, Human, E. coli, Drosophila and multiple MS instruments Lumos, timsTOF, QE, Orbitrap Verlos, QEHF and QEHF-X.<br>Applicability: The model is applicable to the prediction of MS2 spectra for HLA peptides with different modifications.<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Supported are all modification from UNIMOD. Cysteine residues should be carbamidomethylated (C[UNIMOD:4]). There is no limit to sequence length.<br>There are no limitations to valid Precursor Charges.<br>There are no limitations to valid Collision energies.<br>Valid `instrument_types` are `["QE", "LUMOS", "TIMSTOF", "SCIEXTOF"]`.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>

        ### Citation
        AlphaPeptDeep: a modular deep learning framework to predict peptide properties for proteomics. <br>Wen-Feng Zeng, Xie-Xuan Zhou, Sander Willems, Constantin Ammar, Maria Wahle, Isabell Bludau, Eugenia Voytik, Maximillian T. Strauss & Matthias Mann. <br>Nat Commun 13, 7238 (2022). https://doi.org/10.1038/s41467-022-34904-3<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]) 
            inputs['precursor_charges'] = np.array([2, 2]) 
            inputs['collision_energies'] = np.array([25, 25]) 
            inputs['instrument_types'] = np.array(["QE", "QE"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("AlphaPeptDeep_ms2_generic", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ms2_generic/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                        {"name": "instrument_types", "shape": [2,1], "datatype": "BYTES", "data": ["QE", "QE"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ms2_generic/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)),
                    list("name"= "instrument_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("QE", "QE")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "AlphaPeptDeep_ms2_generic",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                list("precursor_charges" = c(2, 2)),
                list("collision_energies" = c(25, 25)),
                list("instrument_types" = c("QE", "QE")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ms2_generic/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                                {"name": "instrument_types", "shape": [2,1], "datatype": "BYTES", "data": ["QE", "QE"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_ms2_generic/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\", \"AAAAAKAKM\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]},");
                    jsonInputStringBuilder.append("{\"name\": \"instrument_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"QE\", \"QE\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: AlphaPeptDeep_ms2_generic
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AlphaPeptDeep_ms2_generic_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /AlphaPeptDeep_rt_generic/infer:
     post:
      tags:
        - Retention Time
      summary: AlphaPeptDeep_rt_generic
      description: |
        ### Summary
        **Data**<br>Source of Data: "Deep learning the collisional cross sections of the peptide universe from a million experimental values."<br>Type of Molecules: The training data includes tryptic, LysC and LysN peptides from HeLA including the modifications Oxidation@M, Carbamidomethyl@C and Acetyl@Protein N-term.<br>Representation of molecular complexity: The training data includes peptides from multiple organisms and the most commonly used PTMs in proteomics.<br>Data Acquisition: LC–MS was performed on an EASY-nLC 1200. Approximately 200 ng of peptides were separated on an in-house 45 cm × 75 µm reversed-phase column at a flow rate of 300 nL min−1 in an oven compartment heated to 60 °C. The column was packed in-house with 1.9 µm C18 beads.<br>Limitations of Training Data: While the model can attempt to predict for arbitrary PTMs it was only trained and evaluated with a limited set of PTMs.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization Target: Retention time (RT)<br>**Model**<br>Interpretability: The model is a black box.<br>Model type: The model performs regression, predicting a continuous RT values.<br>Limitations: The model has not been evaluated on data from different RT systems.<br>**Evaluation**<br>Performance measures: Pearson correlation (R)<br>Choice of performance measures: Pearson correlation (R) is chosen to determine the linear correlation between predicted and experimental values.<br>Single number performance: R2 = 0.986 on regular peptides. R2 = 0.958 on phosphorulated peptides<br>Comparison to Baseline Methods: For prediction accuracy for peptides with PTMs the model was compared with DeepLC showing comparable performance (R2 0.95 vs 0.89).<br>Evaluation methods: The model was evalutaed on Pan human library from Rosenberger et al. 2014.<br>Applicability: The model is applicable to the prediction of MS2 spectra for HLA peptides with common modifications (cysteine carbamidomethylation, methionine oxidation).<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Supported any modification from UNIMOD. Cysteine residues should be carbamidomethylated (C[UNIMOD:4]). There is no limit to sequence length.<br>There are no limitations to valid Precursor Charges.<br>**Output notes**<br>

        ### Citation
        AlphaPeptDeep: a modular deep learning framework to predict peptide properties for proteomics.<br>Wen-Feng Zeng, Xie-Xuan Zhou, Sander Willems, Constantin Ammar, Maria Wahle, et al <br>Nat Commun 13, 7238 (2022). https://doi.org/10.1038/s41467-022-34904-3<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("AlphaPeptDeep_rt_generic", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_rt_generic/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_rt_generic/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "AlphaPeptDeep_rt_generic",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_rt_generic/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/AlphaPeptDeep_rt_generic/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\", \"AAAAAKAKM[UNIMOD:35]\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: AlphaPeptDeep_rt_generic
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AlphaPeptDeep_rt_generic_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Chronologer_RT/infer:
     post:
      tags:
        - Retention Time
      summary: Chronologer_RT
      description: |
        ### Summary
        **Data**<br>Source of the data: Chronologer was trained using a combined database of 2.2 million peptide retention measurements from 11 large datasets that span diverse types of peptide modifications. Individual peptide libraries were aligned to a common reference space using Prosit-based predictions, and re-scaled to the hydrophobic index (% acetonitrile) using data from Khokin et al. for training SSRCalc.<br>Type of molecules: Peptides<br>Data acquisition: All peptides were analyzed by C18 RP-HPLC with an acetonitrile gradient in 0.1% formic acid<br>False positives/negatives: The training data was filtered for 1% FDR. To address this issue, Chronologer was trained using a custom likelihood-based loss function that dynamically masks contributions to the gradient from observations that fall outside an inferred confidence interval based on a user-defined FDR. The loss function includes a learnable scale parameter per dataset to maintain a running estimate of the error from each data source to avoid over- or under-masking of data from datasets with less or more error, respectively.  <br>**Optimization**<br>Optimization target: Peptide retention time<br>Experimental variability: Chronologer errors are comparable to expected column-to-column variation of peptide retention times<br>Metric: Mean absolute error (MAE) was the primary evaluation metric, with the model trained using the FDR-masked negative log-likelihood function that filters likely false positive observations. <br>**Model**<br>Interpretability: The model is a black box.<br>Model type: The model performs regression, predicting a continuous RT value.<br>Limitations of the model: The model is limited C18 RP-HPLC<br>**Evaluation**<br>Performance measures: MAE on datasets spanning multiple proteolytic enzymes, column temperature, and PTM-specific datasets<br>Choice of performance measures: The MAE is the spread parameter for the Laplace distribution, which we experimentally find better models the distribution of chromatographic errors compared to MSE (which implicitly assumes a Gaussian distribution). A diverse set of datasets were chosen to evaluate the performance of the model under different experimental contexts.<br>Comparison to SOTA: The model was compared with SSRCalc as well as Prosit using Skyline/mProphet.<br>Evaluation method: The model was evaluated using Independent datasets.<br>Model performance variability: Not highly variable under the tested conditions.<br>**Input notes**<br>**Output notes**<br>

        ### Citation
        Deep learning from harmonized peptide libraries enables retention time prediction of diverse post translational modifications<br>Wilburn, D.B., Shannon, A.E., Spicer, V., Richards, A.L., Yeung, D., Swaney, D.L., Krokhin, O.V., and Searle, B.C.<br>bioRxiv 2023.05.30.542978;  https://doi.org/10.1101/2023.05.30.542978<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Chronologer_RT", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Chronologer_RT/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Chronologer_RT/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Chronologer_RT",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Chronologer_RT/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Chronologer_RT/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Chronologer_RT
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Chronologer_RT_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Deeplc_hela_hf/infer:
     post:
      tags:
        - Retention Time
      summary: Deeplc_hela_hf
      description: |
        ### Summary
        Find out more about DeepLC <a href="https://github.com/compomics/DeepLC/tree/master">here</a>.<br><br>**Data**<br>Source of the data: The DeepLC HeLa HF model was trained from random parameters on 161 193 tryptic peptides. Modifications for this model include carbamidomethyl, oxidation of methionine, and N-terminal acetylation. The data is presented in <a href="https://pubs.acs.org/doi/abs/10.1021/acs.jproteome.7b00602">10.1021/acs.jproteome.7b00602</a> and available at <a href="https://www.ebi.ac.uk/pride/archive/projects/PXD006932">PXD006932</a>. The data was processed with MaxQuant v1.5.8.3 and the obtained LC retention apex was used as its retention time target. The HeLa cell line was run on a reversed phase column with 30 minutes gradients using standard mobile phase composition. For all details please see the original publication reffered to at the start of this paragrpah. The data was randomly split into a training (137 821), validation (7 252), and test (16 120) split. The validation split was used for early stopping of the model. The data and split information is available <a href="https://static-content.springer.com/esm/art%3A10.1038%2Fs41592-021-01301-5/MediaObjects/41592_2021_1301_MOESM3_ESM.csv">here</a>. The final model (available here) was trained on the combination of training and testing sets combined, the validation set was still used for early stopping.<br>Type of molecules: The training data represents tryptic peptides with modifications carbamidomethyl, oxidation of methionine, and N-terminal acetylation.<br>Representation of complexity: The model is intended for tryptic peptides with modifications carbamidomethyl, oxidation of methionine, and N-terminal acetylation. Any modifications that are not too much out of the chemical space of natural occuring amino acids should be predicted with relatively high accuracy.<br>Data acquisition: The data was acquired in the same lab with the same instruments and settings.<br>Limitations of the training data: Modification space is limited and are limited to similar chromatographic conditions (reversed phase column and ACN+FA+H2O based mobile phase).<br>False positives/negatives: FDR filter was set for identifications was set to 1%. The model is expected to be robust against this small number of false positives/negatives.<br><br>**Optimization**<br>Optimization target: The optimization target is to minimize the mean absolute error between the predicted and observed retention times.<br>Experimental variability: The claimed performance is higher than the experimental variability with 1.7% relative mean absolute error (normalized against the delta of first and last identified peptide).<br>Metric: Apex of the extracted ion chromatogram compared against the predicted retention time. Other metrics for performance evaluation are the Pearson correlation coefficient and the 95th error percentile.<br><br>**Model**<br>Interpretability: The model is a black box, but can be interrogated with methods such as saliency maps and SHAP. <br>Model type: The model is a regression model, predicting continuous values for RT.<br>Limitations: The model is limited to reversed phase chromatography with ACN+FA+H2O based mobile phase. The model is expected to have optimal performance for tryptic peptides with modifications carbamidomethyl, oxidation of methionine, and N-terminal acetylation. It can interpolate and extraplote to different types of peptides.<br><br>**Evaluation**<br>Choice of performance measures: Mean absolute error, Pearson correlation coefficient, and 95th error percentile.<br>Evaluation methods: The model was evaluated on a test set that was not used during training and on independent data sets.<br>Independent data: Yes, the model has been evaluated on independent datasets.<br>Increase in identification: It is expected to be be between 1-2%. Specificity in identification and quantification is substantially improved. This largely depends on the proteomics experiment, especially for complex search spaces it is expected to improve more than the previous mentioned numbers. <br>Data applicability: LC-MS/MS data with reversed phase chromatography and ACN+FA+H2O based mobile phase.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are 1 to 60 AA. Supported are all modification from UNIMOD. Cysteine residues are assumed to be carbamidomethylated (C == C[UNIMOD:4]).<br><br>**Output notes**<br>

        ### Citation
        DeepLC can predict retention times for peptides that carry as-yet unseen modifications<br>Robbin Bouwmeester, Ralf Gabriels, Niels Hulstaert, Lennart Martens & Sven Degroeve<br>Nature Methods 18, 1363–1369 (2021) doi: 10.1038/s41592-021-01301-5<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK'])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Deeplc_hela_hf", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Deeplc_hela_hf/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [4,1], "datatype": "BYTES", "data": ['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK']}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Deeplc_hela_hf/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(4,1), "datatype"= "BYTES", "data"= c('LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK')))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Deeplc_hela_hf",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c('LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK')))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Deeplc_hela_hf/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [4,1], "datatype": "BYTES", "data": ['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK']}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Deeplc_hela_hf/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [4,1], \"datatype\": \"BYTES\", \"data\": ['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK']}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Deeplc_hela_hf
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Deeplc_hela_hf_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /IM2Deep/infer:
     post:
      tags:
        - Collisional cross section
      summary: IM2Deep
      description: |
        ### Summary
        IM2Deep, is a deep learning-based peptide collisional cross section (CCS) predictor that uses a similar architecture to the retention time predictor, DeepLC. <br>As a result, IM2Deep is able to predict CCS values for both unmodified as well as modified peptides, even if those modifications were not seen during training.<br>Find out more about this model on <a href="https://github.com/compomics/IM2Deep">GitHub</a>.<br><br>**Data**<br>Source of the data: IM2Deep was trained (81%), validated (9%) and tested (10%) on ~1.2M unique peptidoform-charge pairs, originating from three different data sets: PXD019086, PXD038782 and PXD042416. To account for experimental drifts between the data sets, we aligned them by calculating the linear offset (y = ax + b) between overlapping peptide-charge state pairs, as previously described. <br>Type of molecules: The first data set includes 718,917 unique combinations of peptide sequence, charge state, and, where applicable, modifications (methionine oxidation, cysteine carbamidomethylation, and N-terminal acetylation).  The second data set, described in (24), contains 5,202 unique peptidoform-charge state combinations and features a broader range of modifications, including a distinction between symmetrical and asymmetrical arginine dimethylation. Since IM2Deep cannot differentiate isomeric peptides, the mean CCS value of these isomers was used for dimethylated peptide-charge state pairs. The last data set consists of 437,479 unique (modified) peptide-charge pairs, most of which are non-tryptic, and contain a larger range of charge states (1-6).<br>Representation of complexity: The model generalizes well across both tryptic and non-tryptic peptides. Any modifications that are not too much out of the chemical space of natural occuring amino acids should be predicted with relatively high accuracy.<br>Data acquisition: The three datasets were all acquired in different labs, but on the same instrument (timsTOF Pro).<br>Limitations of the training data: Modification space is limited to those inside the chemical space of natural occuring amino acids.<br>False positives/negatives: FDR filter was set for identifications was set to 1%. The model is expected to be robust against this small number of false positives/negatives.<br><br>**Optimization**<br>Optimization target: The optimization target is to minimize the mean absolute error between the predicted and observed collisional cross-sections.<br><br>**Model**<br>Interpretability: The model is a black box, but can be interrogated with methods such as saliency maps and SHAP.<br>Model type: The model is a regression model, predicting continuous values for CCS. The model was initialized with random weights drawn from a normal distribution (μ=0.0, σ=1.0), and training was conducted on a single NVIDIA Geforce RTX 4090 GPU for up to 300 epochs, with early stopping employed to prevent overfitting.<br>Limitations: Modification space for which accurate predictions can be made is limited to those inside the chemical space of natural occuring amino acids.<br><br>**Evaluation**<br>Choice of performance measures: Mean absolute error, Pearson correlation coefficient, median relative error.<br>Single number performance: Evaluation on the test set demonstrated a mean absolute error of 6.26 Å², a median relative error of 0.91%, and a Pearson correlation coefficient of 0.996.<br>Comparison to baselines: Performance was not compared to baseline methods.<br>Evaluation methods: The model was evaluated on a test set that was not used during training and on independent data sets.<br>Independent data: Yes, the model has been evaluated on independent datasets.<br>Model performance variability: Variable Performance for higher charge states (>=4+) is more variable than performance for lower charge states, because of less training data.<br>Data applicability: LC-IM-MS/MS data with trapped ion mobility spectrometry. Other ion mobility techniques such as FAIMS or TWIMS are not supported.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are 1 to 60 AA. Supported are all modification from UNIMOD. Cysteine residues are assumed to be carbamidomethylated (C == C[UNIMOD:4]).<br>There are no limitations to valid Precursor Charges.<br><br>**Output notes**<br>

        ### Citation
        TIMS2Rescore: A DDA-PASEF optimized data-driven rescoring pipeline based on MS2Rescore<br>Arthur Declercq, Robbe Devreese, Jonas Scheid, Caroline Jachmann, et al. <br>bioRxiv 2024.05.29.596400; doi: https://doi.org/10.1101/2024.05.29.596400<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]) 
            inputs['precursor_charges'] = np.array([2,2])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("IM2Deep", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/IM2Deep/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2,2]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/IM2Deep/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2,2)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "IM2Deep",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM")),
                list("precursor_charges" = c(2,2)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/IM2Deep/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2,2]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/IM2Deep/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\", \"AAAAAKAKM\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2,2]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: IM2Deep
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IM2Deep_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2019_intensity/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2019_intensity
      description: |
        ### Summary
        **Data**<br>Source of the data: The model was trained using data from the ProteomeTools project. This project generated a large number of synthetic peptides and their tandem mass spectra. The data includes 21,764,501 high-quality spectra from 576,256 unique precursors, covering 19,749 of the 20,040 human protein coding genes.<br>Type of molecules: The training data primarily consists of tryptic peptides. The model was also tested on non-tryptic peptides.<br>Representation of complexity: The training data covers a significant portion of the human proteome, including many isoforms and post-translational modifications. The data includes 550,000 tryptic peptides and 21 million high-quality tandem mass spectra. The initial dataset of high-quality synthetic peptide spectra was extended by 219,089 tryptic peptides to improve coverage of human proteins and isoforms.<br>Data acquisition: The data was acquired using one instrument (Orbitrap Fusion Lumos), with six different collision energies (20, 23, 25, 28, 30, 35).<br>Limitations of the training data: The model was initially trained on tryptic peptides, though it has been shown to generalize to non-tryptic peptides. The model may benefit from inclusion of more non-tryptic data, longer peptides, and higher charge states in future training.<br>False positives/negatives: The training data was filtered for 1% FDR and an Andromeda score greater than 100.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on specific fragmentation techniques (HCD), mass analyzers (Orbitrap), and collision energies (20, 23, 25, 28, 30, 35). It interpoaltes well in this range of collision energies but has not been evaluated far outside this range. It has not been evaluated under different conditions or with different instruments or fragmentation techniques. Performance on non tryptic peptides, is lower.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Single number performance: When reporting a single number for performance, the document uses the median spectral angle. The normalized spectral angle is adjusted to range from 1 (high correlation) to 0 (low correlation).<br>Comparison to baselines: The model's performance was compared to other fragment ion intensity prediction models such as MS2PIP and pDeep.<br>Evaluation methods: The model was evaluated using cross-validation and an independent holdout dataset. The model was evaluated on independent test data acquired on different instruments in different labs. The model’s performance was also evaluated using novel experiments.<br>Independent data: The model was evaluated on independent test data, including a large external dataset from Bekker-Jensen et al. This evaluation was performed without re-training the model.<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different collision energies, peptides, and datasets. The model’s predictions can be calibrated to the NCE used for acquisition.<br>Data applicability: The model is applicable to a wide range of peptide data, but it is not applicable to data using different fragmentation techniques or mass analyzers from those used in training.<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Valid Precursor Charges are 1 to 6.<br>There are no limitations to valid Collision energies.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Prosit: proteome-wide prediction of peptide tandem mass spectra by deep learning.<br>Gessulat, S., Schmidt, T., Zolg, D.P. et al.<br>Nat Methods 16, 509–518 (2019). https://doi.org/10.1038/s41592-019-0426-7<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAK", "AAAAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2019_intensity", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_intensity/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_intensity/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAK", "AAAAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2019_intensity",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAK", "AAAAAKAK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_intensity/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_intensity/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAK\", \"AAAAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2019_intensity
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2019_intensity_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2019_irt/infer:
     post:
      tags:
        - Retention Time
      summary: Prosit_2019_irt
      description: |
        ### Summary
        **Data**<br>Source of the data: The data used to train the retention time model comes from the ProteomeTools project. This project aims to provide high-quality reference MS/MS data of synthetic peptides, covering the entire human proteome and important post-translational modifications.<br>Type of molecules: The training data represents tryptic peptides.<br>Representativeness of the training data: The ProteomeTools project includes a large number of synthetic peptides. The data covers 19,749 of the 20,040 human protein coding genes (98.5%) and distinguishes 26,549 of the 42,164 Swiss-Prot annotated isoforms (63%).<br>Data acquisition: The data was acquired using similar instruments, settings and mass analyzers. Specifically, an Orbitrap Fusion Lumos mass spectrometer coupled with a Dionex 3000 HPLC system was used for data acquisition.<br>Limitations of the training data: The model was trained on tryptic peptides from human origin. There is a possibility that additional liquid chromatography parameters not captured by iRT values may lead to suboptimal predictions.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Mean squared error to compare experimental and predicted iRT.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model performs regression, predicting a continuous iRT value.<br>Limitations of the model: The model is limited by the type and conditions of chromatography used for retention time prediction. Within limits the predictions can be aligned to experimental values with a subset of the data.<br>**Evaluation**<br>Performance measures: Pearson correlation (R) and Δt95%, the time window required to encompass 95% of all peptides around the diagonal.<br>Choice of performance measures: Pearson correlation (R) is chosen to determine the linear correlation between predicted and experimental values. The Δt95% is chosen to quantify the deviation between the predicted and measured retention times and to indicate the time window in which 95% of peptides are found.<br>Single number for performance: When reporting a single number for performance, the R value is used, which represents the linear correlation between predicted and measured values.<br>Comparison to simpler methods: The model's performance was compared to SSRCalc and Elude.<br>Evaluation method: The model was evaluated using a holdout set and cross-validation. The data was split into three parts: one for training, a test set to control for overfitting, and a holdout set to estimate performance. The model was also evaluated on an independent dataset and showed improved accuracy by transfer learning.<br>Independent data: The model has been evaluated on independent data acquired by Bekker-Jensen et al. and on external datasets. The model was also evaluated on non-tryptic peptides.<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>**Output notes**<br>The model outputs indexed retention time. As index a subset of PROCAL peptides were used.<br>

        ### Citation
        Prosit: proteome-wide prediction of peptide tandem mass spectra by deep learning.<br>Gessulat, S., Schmidt, T., Zolg, D.P. et al.<br>Nat Methods 16, 509–518 (2019). https://doi.org/10.1038/s41592-019-0426-7<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAKM[UNIMOD:35]"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2019_irt", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_irt/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_irt/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("AAAAAKAKM[UNIMOD:35]")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2019_irt",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAKM[UNIMOD:35]")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_irt/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAKM[UNIMOD:35]"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2019_irt/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAKM[UNIMOD:35]\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2019_irt
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2019_irt_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2020_intensity_CID/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2020_intensity_CID
      description: |
        ### Summary
        **Data**<br>Source of the data: The model was trained using data from the ProteomeTools project. This included both previously published (tryptic) data and data generated specifically for this study (non-tryptic). The data consisted of tandem mass spectra acquired from synthetic peptides. This project synthesized and analyzed over 300,000 non-tryptic peptides using multi-modal LC-MS/MS. These peptides included HLA class I & II ligands and products of the proteases AspN and LysN.<br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN.<br>Complexity: The training data covers nearly all possible N- and C-terminal amino acid combinations, except for peptides with cysteine residues at both the N- and C-termini. The data includes a range of peptide lengths from 7 to 30 amino acids.<br>Data Acquisition: The synthetic peptides were analyzed using an ion trap mass spectrometer (ITMS).<br>Limitations of Training Data: The model was trained on synthetic peptides. The training data underrepresents peptides with cysteine residues at both the N- and C-termini. The model was not trained on peptides containing free cysteine side chains or other amino acid modifications.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on specific fragmentation techniques (CID) and mass analyzers (IonTrap).  It has not been evaluated under different conditions or with different instruments or fragmentation techniques.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Comparison to Baseline Methods: The model was compared against the previously published HCD Prosit 2019 model.<br>Evaluation methods: The model was evaluated using cross-validation (training, testing, and holdout sets), and on independent datasets (re-analyzing data from other publications).<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different peptides, and datasets.<br>Data applicability: The model is applicable to both tryptic and non-tryptic peptides, particularly HLA peptides. It is applicable to data acquired using CID fragmentation. It is not applicable to data acquired using other fragmentation methods or using different mass analyzers (e.g., HCD fragmentation and Orbitrap analyzer, for which a separate model was trained).<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Valid Precursor Charges are 1 to 6.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Deep learning boosts sensitivity of mass spectrometry-based immunopeptidomics.<br>Wilhelm, M., Zolg, D.P., Graber, M. et al. <br>Nat Commun 12, 3346 (2021). https://doi.org/10.1038/s41467-021-23713-9<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAK", "AAAAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2020_intensity_CID", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_CID/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_CID/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAK", "AAAAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2020_intensity_CID",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAK", "AAAAAKAK")),
                list("precursor_charges" = c(1,2)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_CID/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_CID/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAK\", \"AAAAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2020_intensity_CID
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2020_intensity_CID_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2020_intensity_HCD/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2020_intensity_HCD
      description: |
        ### Summary
        **Data**<br>Source of the data: The model was trained using data from the ProteomeTools project. This included both previously published (tryptic) data and data generated specifically for this study (non-tryptic). The data consisted of tandem mass spectra acquired from synthetic peptides. This project synthesized and analyzed over 300,000 non-tryptic peptides using multi-modal LC-MS/MS. These peptides included HLA class I & II ligands and products of the proteases AspN and LysN.<br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN.<br>Representation of molecular complexity: The training data was designed to represent a wide variety of peptide sequences and fragmentation patterns, including both tryptic and non-tryptic peptides. The data included a large number of peptides with different amino acid combinations, covering nearly all possible N- and C-terminal amino acid combinations. This was done to address the challenge of identifying non-tryptic HLA peptides, whose fragmentation characteristics can be distinct from tryptic peptides.<br>Data acquisition: The data was acquired using one instrument (Orbitrap Fusion Lumos), with six different collision energies (20, 23, 25, 28, 30, 35).<br>Limitations of the training data: The model was not trained on peptides containing free cysteine side chains or other amino acid modifications that may be identified on HLA peptides. Also, the training data underrepresents peptides with cysteine residues at the N- and C-termini.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on specific fragmentation techniques (HCD), mass analyzers (Orbitrap), and collision energies (20, 23, 25, 30, 35). It interpoaltes well in this range of collision energies but has not been evaluated far outside this range. It has not been evaluated under different conditions or with different instruments or fragmentation techniques.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Single number performance: The spectral angle was used to provide an overall measure of performance, but the distribution of spectral angle values was also examined to assess the model's performance across different types of peptides and conditions.<br>Comparison to baseline methods: The model's performance was compared to the previously published Prosit 2019 model which was trained on tryptic peptides. The new model showed a substantial improvement, especially for non-tryptic peptides. The model was also implicitly compared to the performance of traditional search engines by showing the improvements gained when using the model to rescore peptide spectrum matches.<br>Evaluation methods: The model was evaluated using cross-validation (training, testing, and holdout sets), and on independent datasets (re-analyzing data from other publications). It was also evaluated using novel experiments, such as immunogenicity testing of neo-epitopes identified using the model.<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different collision energies, peptides, and datasets. The model’s predictions can be calibrated to the NCE used for acquisition.<br>Data applicability: The model is applicable to both tryptic and non-tryptic peptides, particularly HLA peptides. It is applicable to data acquired using HCD fragmentation. It is not applicable to data acquired using other fragmentation methods or using different mass analyzers (e.g., CID fragmentation and ion trap analyzer, for which a separate model was trained).<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Valid Precursor Charges are 1 to 6.<br>There are no limitations to valid Collision energies.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Deep learning boosts sensitivity of mass spectrometry-based immunopeptidomics.<br>Wilhelm, M., Zolg, D.P., Graber, M. et al. <br>Nat Commun 12, 3346 (2021). https://doi.org/10.1038/s41467-021-23713-9<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAK", "AAAAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2020_intensity_HCD", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_HCD/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_HCD/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAK", "AAAAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2020_intensity_HCD",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAK", "AAAAAKAK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_HCD/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_HCD/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAK\", \"AAAAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2020_intensity_HCD
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2020_intensity_HCD_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2020_intensity_TMT/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2020_intensity_TMT
      description: |
        ### Summary
        **Data**<br>Source of the data: The model was trained using data from the ProteomeTools project. This included both tryptic data and non-tryptic TMT-labeled Data. The data consisted of tandem mass spectra acquired from synthetic peptides. This project synthesized and analyzed over 650,000 tryptic and non-tryptic peptides using multi-modal LC-MS/MS.<br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN.<br>Representation of molecular complexity: The training data was designed to represent a wide variety of peptide sequences and fragmentation patterns, including both tryptic and non-tryptic TMT-labeled peptides. The data included a large number of peptides with different amino acid combinations, covering nearly all possible N- and C-terminal amino acid combinations. This was done to address the challenge of identifying non-tryptic HLA peptides, whose fragmentation characteristics can be distinct from tryptic peptides.<br>Data acquisition: The data was acquired using one instrument (Orbitrap Fusion Lumos), with six different collision energies (20, 23, 25, 28, 30, 35) and on two different Mass analyzers Fourier transform mass analyzer (FTMS) and ion trap mass analyzer (ITMS).<br>Limitations of the training data: The model was not trained on peptides containing free cysteine side chains or other amino acid modifications that may be identified on HLA peptides. Also, the training data only included peptides with TMT label on the n-treminus.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on two fragmentation techniques (HCD and CID), mass analyzers (Orbitrap and Iontrap), and collision energies (20, 23, 25, 30, 35). It interpoaltes well in this range of collision energies but has not been evaluated far outside this range. It has not been evaluated under different conditions or with different instruments or fragmentation techniques.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Single number performance: The spectral angle was used to provide an overall measure of performance, but the distribution of spectral angle values was also examined to assess the model's performance across different types of peptides and conditions.<br>Comparison to SOTA: No model was predicting retention time for TMT-labeled peptides at that time<br>Evaluation methods: The model was evaluated using cross-validation (training, testing, and holdout sets), and on independent datasets (re-analyzing data from other publications). <br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different collision energies, peptides, and datasets. The model’s predictions can be calibrated to the NCE used for acquisition.<br>Data applicability: The model is applicable to both tryptic and non-tryptic TMT-labeled peptides. It is applicable to data acquired using HCD and CID fragmentation. It is not applicable to data acquired using other fragmentation methods or using different mass analyzers. (e.g. TOF analyzer)<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]) as well as SILAC (`K[UNIMOD:259]`, `R[UNIMOD:267]`); TMT (`K[UNIMOD:737]`, `[UNIMOD:737]-`); TMTpro (`K[UNIMOD:2016]`, `[UNIMOD:2016]-`); iTRAQ (`K[UNIMOD:214]`, `[UNIMOD:214]-`, `K[UNIMOD:730]`, `[UNIMOD:730]-`) one of the N-terminal modifications is required. Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Added support for doubly modified Lysine with TMT/iTRAQ and SIlac (K[UNIMOD:737][UNIMOD:259],K[UNIMOD:2016][UNIMOD:259],K[UNIMOD:214][UNIMOD:259],K[UNIMOD:730][UNIMOD:259]).<br>Valid Precursor Charges are 1 to 6.<br>There are no limitations to valid Collision energies.<br>Valid fragmentation types are `HCD` and `CID`.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Prosit-TMT: Deep Learning Boosts Identification of TMT-Labeled Peptides<br>Wassim Gabriel, Matthew The, Daniel P. Zolg, Florian P. Bayer, et al.<br>Analytical Chemistry 2022 94 (20), 7181-7190 DOI: 10.1021/acs.analchem.1c05435<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25]) 
            inputs['fragmentation_types'] = np.array(["HCD", "CID"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2020_intensity_TMT", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_TMT/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                        {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_TMT/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)),
                    list("name"= "fragmentation_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("HCD", "CID")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2020_intensity_TMT",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)),
                list("fragmentation_types" = c("HCD", "CID")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_TMT/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                                {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_intensity_TMT/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"[UNIMOD:737]-AAAAAKAK\", \"[UNIMOD:737]-AAAAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]},");
                    jsonInputStringBuilder.append("{\"name\": \"fragmentation_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"HCD\", \"CID\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2020_intensity_TMT
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2020_intensity_TMT_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2020_irt_TMT/infer:
     post:
      tags:
        - Retention Time
      summary: Prosit_2020_irt_TMT
      description: |
        ### Summary
        **Data**<br>Source of the data: The data used to train the retention time model comes from the ProteomeTools project. This project aims to provide high-quality reference MS/MS data of synthetic peptides, covering the entire human proteome and important post-translational modifications.<br>Type of molecules: The training data represents tryptic and non-tryptic TMT-labeled peptides.<br>Representativeness of the training data: The ProteomeTools project includes a large number of synthetic peptides. The data covers 19,749 of the 20,040 human protein coding genes (98.5%) and distinguishes 26,549 of the 42,164 Swiss-Prot annotated isoforms (63%).<br>Data acquisition: The data was acquired using similar instruments, settings and mass analyzers. Specifically, an Orbitrap Fusion Lumos mass spectrometer coupled with a Dionex 3000 HPLC system was used for data acquisition.<br>Limitations of the training data: The model was trained on tryptic peptides from human origin. There is a possibility that additional liquid chromatography parameters not captured by iRT values may lead to suboptimal predictions.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model performs regression, predicting a continuous iRT value.<br>Limitations of the model: The model is limited by the type and conditions of chromatography used for retention time prediction. Within limits the predictions can be aligned to experimental values with a subset of the data.<br>**Evaluation**<br>Performance measures: Pearson correlation (R) and Δt95%, the time window required to encompass 95% of all peptides around the diagonal.<br>Choice of performance measures: Pearson correlation (R) is chosen to determine the linear correlation between predicted and experimental values. The Δt95% is chosen to quantify the deviation between the predicted and measured retention times and to indicate the time window in which 95% of peptides are found.<br>Single number for performance: When reporting a single number for performance, the R value is used, which represents the linear correlation between predicted and measured values.<br>Comparison to SOTA: No model was predicting retention time for TMT-labeled peptides at that time<br>Evaluation method: The model was evaluated using a holdout set and cross-validation. The data was split into three parts: one for training, a test set to control for overfitting, and a holdout set to estimate performance. The model was also evaluated on an independent dataset and showed improved accuracy by transfer learning.<br>Independent data: The model has been evaluated on independent data acquired by Bayer et al. and on external datasets. The model was also evaluated on TMT-Pro and iTRAQ labeled peptides.<br>Data applicability: The model is applicable to isobaric labeled peptides (TMT, TMT-PRO, iTRAQ4 and iTRAQ8) <br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]) as well as SILAC (`K[UNIMOD:259]`, `R[UNIMOD:267]`); TMT (`K[UNIMOD:737]`, `[UNIMOD:737]-`); TMTpro (`K[UNIMOD:2016]`, `[UNIMOD:2016]-`); iTRAQ (`K[UNIMOD:214]`, `[UNIMOD:214]-`, `K[UNIMOD:730]`, `[UNIMOD:730]-`) one of the N-terminal modifications is required. Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>**Output notes**<br>The model outputs indexed retention time. As index a subset of PROCAL peptides were used.<br>

        ### Citation
        Prosit-TMT: Deep Learning Boosts Identification of TMT-Labeled Peptides<br>Wassim Gabriel, Matthew The, Daniel P. Zolg, Florian P. Bayer, et al.<br>Analytical Chemistry 2022 94 (20), 7181-7190 DOI: 10.1021/acs.analchem.1c05435<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2020_irt_TMT", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_irt_TMT/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_irt_TMT/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2020_irt_TMT",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_irt_TMT/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2020_irt_TMT/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2020_irt_TMT
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2020_irt_TMT_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2023_intensity_XL_CMS2/infer:
     post:
      tags:
        - Cross-linking fragment intensity
      summary: Prosit_2023_intensity_XL_CMS2
      description: |
        ### Summary
        The HCD Prosit 2020 model was fine-tuned using using 251,449 sets of cross-linked peptides, specifically those created from DSSO and DSBU. <br>The model's structure was adjusted to accommodate two input peptides and generate both non-xl and xl fragments in the output. <br>The dataset was divided into three parts: training (80% - 198,294 sets), validation (10% - 26,610 sets), and test (10% - 26,545 sets).<br>This model achieved a SA (a measure of accuracy) of at least 0.83, which is a significant improvement compared to the HCD Prosit 2020 model's performance on cross-linked peptides, where the accuracy was SA ≥ 0.58<br>

        ### Citation
        Prosit-XL: enhanced cross-linked peptide identification by accurate fragment intensity prediction to study protein-protein interactions and protein structures<br>Mostafa Kalhor, Cemil Can Saylan, Mario Picciani, Lutz Fischer, Falk Schimweg, Joel Lapin, Juri Rappsilber, Mathias Wilhelm<br>bioRxiv 2024.12.15.627797; doi: https://doi.org/10.1101/2024.12.15.627797<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences_1'] = np.array(["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]) 
            inputs['peptide_sequences_2'] = np.array(["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]) 
            inputs['precursor_charges'] = np.array([3,4]) 
            inputs['collision_energies'] = np.array([28, 28])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2023_intensity_XL_CMS2", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS2/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences_1", "shape": [2,1], "datatype": "BYTES", "data": ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]},
                        {"name": "peptide_sequences_2", "shape": [2,1], "datatype": "BYTES", "data": ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [3,4]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [28, 28]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS2/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences_1", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR")),
                    list("name"= "peptide_sequences_2", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(3,4)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(28, 28)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2023_intensity_XL_CMS2",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences_1" = c("DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR")),
                list("peptide_sequences_2" = c("NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER")),
                list("precursor_charges" = c(3,4)),
                list("collision_energies" = c(28, 28)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS2/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences_1", "shape": [2,1], "datatype": "BYTES", "data": ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]},
                                {"name": "peptide_sequences_2", "shape": [2,1], "datatype": "BYTES", "data": ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [3,4]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [28, 28]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS2/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences_1\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"DIADAVTAAGVEVAK[UNIMOD:1896]SEVR\", \"AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences_2\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"NFLVPQGK[UNIMOD:1896]AVPATK\", \"SANIALVLYK[UNIMOD:1896]DGER\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [3,4]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [28, 28]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2023_intensity_XL_CMS2
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2023_intensity_XL_CMS2_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2023_intensity_XL_CMS3/infer:
     post:
      tags:
        - Cross-linking fragment intensity
      summary: Prosit_2023_intensity_XL_CMS3
      description: |
        ### Summary
        The XL_Prosit_CMS3 2023 model was trained using 37,938 sets of modifed linear peptides (MS3 spectra), those contain Alkene and Thiol as modidifcations  <br>This model achieved a SA (a measure of accuracy) of at least 0.83<br>

        ### Citation
        Prosit-XL: enhanced cross-linked peptide identification by accurate fragment intensity prediction to study protein-protein interactions and protein structures<br>Mostafa Kalhor, Cemil Can Saylan, Mario Picciani, Lutz Fischer, Falk Schimweg, Joel Lapin, Juri Rappsilber, Mathias Wilhelm<br>bioRxiv 2024.12.15.627797; doi: https://doi.org/10.1101/2024.12.15.627797<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR"]) 
            inputs['precursor_charges'] = np.array([1,2])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2023_intensity_XL_CMS3", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS3/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS3/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2023_intensity_XL_CMS3",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR")),
                list("precursor_charges" = c(1,2)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS3/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_XL_CMS3/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"TQNVLGEK[UNIMOD:1881]GRR\", \"TQNVLGEK[UNIMOD:1881]GRR\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2023_intensity_XL_CMS3
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2023_intensity_XL_CMS3_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2023_intensity_timsTOF/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2023_intensity_timsTOF
      description: |
        ### Summary
        **Data**<br>Source of the data: The HCD Prosit 2020 model was fine-tuned using  a dataset of 277,781 MS/MS spectra acquired from both tryptic and non-tryptic synthetic peptides, measured on a timsTOF Pro instrument<br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN.<br>Representation of molecular complexity: The training data was designed to represent a wide variety of peptide sequences and fragmentation patterns, including both tryptic and non-tryptic. The data included a large number of peptides with different amino acid combinations, covering nearly all possible N- and C-terminal amino acid combinations. This was done to address the challenge of identifying non-tryptic HLA peptides, whose fragmentation characteristics can be distinct from tryptic peptides.<br>Data acquisition: The data was acquired using one instrument (timsTOF Pro), with a range of collision energies from 20.81 EV to 69.77 eV.<br>Limitations of the training data: The model was not trained on peptides containing free cysteine side chains or other amino acid modifications that may be identified on HLA peptides.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on two fragmentation techniques (HCD and CID), mass analyzers (Orbitrap and Iontrap), and collision energies (20, 23, 25, 30, 35). It interpoaltes well in this range of collision energies but has not been evaluated far outside this range. It has not been evaluated under different conditions or with different instruments or fragmentation techniques.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Single number performance: The spectral angle was used to provide an overall measure of performance, but the distribution of spectral angle values was also examined to assess the model's performance across different types of peptides and conditions.<br>Comparison to SOTA: No model was predicting citrullinated peptides at the time.<br>Evaluation methods: The model was evaluated using cross-validation (training, testing, and holdout sets), and on independent datasets (re-analyzing data from other publications). <br>Independent data: The model has been evaluated on independent data acquired Phulphagar et al. and Fossati, A. et al.<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different collision energies, peptides, and datasets. The model’s predictions can be calibrated to the NCE used for acquisition.<br>Data applicability: The model is applicable to both tryptic and non-tryptic un-modified and citrullinated peptides. It is applicable to data acquired using HCD and CID fragmentation. It is not applicable to data acquired using other fragmentation methods or using different mass analyzers. (e.g. TOF analyzer)<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Valid Precursor Charges are 1 to 6.<br>There are no limitations to valid Collision energies.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Fragment ion intensity prediction improves the identification rate of non-tryptic peptides in timsTOF.<br>Adams, C., Gabriel, W., Laukens, K. et al.<br>Nat Commun 15, 3956 (2024). https://doi.org/10.1038/s41467-024-48322-0<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAK", "AAAAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2023_intensity_timsTOF", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_timsTOF/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_timsTOF/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAK", "AAAAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2023_intensity_timsTOF",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAK", "AAAAAKAK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_timsTOF/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2023_intensity_timsTOF/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAK\", \"AAAAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2023_intensity_timsTOF
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2023_intensity_timsTOF_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2024_intensity_PTMs_gl/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2024_intensity_PTMs_gl
      description: |
        ### Summary
        PTM-Model for ProSIMSIt<br>

        ### Citation
        

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25]) 
            inputs['fragmentation_types'] = np.array(["HCD", "CID"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2024_intensity_PTMs_gl", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_PTMs_gl/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                        {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_PTMs_gl/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)),
                    list("name"= "fragmentation_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("HCD", "CID")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2024_intensity_PTMs_gl",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)),
                list("fragmentation_types" = c("HCD", "CID")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_PTMs_gl/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                                {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_PTMs_gl/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"[UNIMOD:737]-AAAAAKAK[UNIMOD:737]\", \"[UNIMOD:737]-AAAAY[UNIMOD:21]AR\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]},");
                    jsonInputStringBuilder.append("{\"name\": \"fragmentation_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"HCD\", \"CID\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2024_intensity_PTMs_gl
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2024_intensity_PTMs_gl_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2024_intensity_XL_NMS2/infer:
     post:
      tags:
        - Cross-linking fragment intensity 
      summary: Prosit_2024_intensity_XL_NMS2
      description: |
        ### Summary
        The HCD Prosit 2020 model was fine-tuned using using 251,449 sets of cross-linked peptides, specifically those created from DSSO and DSBU. <br>The model's structure was adjusted to accommodate two input peptides and generate both non-xl and xl fragments in the output. <br>The dataset was divided into three parts: training (80% - 198,294 sets), validation (10% - 26,610 sets), and test (10% - 26,545 sets).<br>This model achieved a SA (a measure of accuracy) of at least 0.83, which is a significant improvement compared to the HCD Prosit 2020 model's performance on cross-linked peptides, where the accuracy was SA ≥ 0.58<br>

        ### Citation
        Prosit-XL: enhanced cross-linked peptide identification by accurate fragment intensity prediction to study protein-protein interactions and protein structures<br>Mostafa Kalhor, Cemil Can Saylan, Mario Picciani, Lutz Fischer, Falk Schimweg, Joel Lapin, Juri Rappsilber, Mathias Wilhelm<br>bioRxiv 2024.12.15.627797; doi: https://doi.org/10.1101/2024.12.15.627797<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences_1'] = np.array(["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]) 
            inputs['peptide_sequences_2'] = np.array(["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]) 
            inputs['precursor_charges'] = np.array([3,4]) 
            inputs['collision_energies'] = np.array([28, 28])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2024_intensity_XL_NMS2", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_XL_NMS2/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences_1", "shape": [2,1], "datatype": "BYTES", "data": ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]},
                        {"name": "peptide_sequences_2", "shape": [2,1], "datatype": "BYTES", "data": ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [3,4]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [28, 28]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_XL_NMS2/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences_1", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR")),
                    list("name"= "peptide_sequences_2", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(3,4)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(28, 28)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2024_intensity_XL_NMS2",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences_1" = c("DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR")),
                list("peptide_sequences_2" = c("NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER")),
                list("precursor_charges" = c(3,4)),
                list("collision_energies" = c(28, 28)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_XL_NMS2/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences_1", "shape": [2,1], "datatype": "BYTES", "data": ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]},
                                {"name": "peptide_sequences_2", "shape": [2,1], "datatype": "BYTES", "data": ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [3,4]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [28, 28]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_XL_NMS2/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences_1\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"DIADAVTAAGVEVAK[UNIMOD:1896]SEVR\", \"AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences_2\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"NFLVPQGK[UNIMOD:1896]AVPATK\", \"SANIALVLYK[UNIMOD:1896]DGER\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [3,4]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [28, 28]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2024_intensity_XL_NMS2
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2024_intensity_XL_NMS2_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2024_intensity_cit/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2024_intensity_cit
      description: |
        ### Summary
        **Data**<br>Source of the data: The data used to train the retention time model comes from the ProteomeTools project. This project aims to provide high-quality reference MS/MS data of synthetic peptides, covering the entire human proteome and important post-translational modifications.<br>Type of molecules: The training data represents tryptic and non-tryptic unmodified peptides. Citrullinated tryptic/non-tryptic peptides were also included.<br>Representativeness of the training data: The ProteomeTools project includes a large number of synthetic peptides. The data covers 19,749 of the 20,040 human protein coding genes (98.5%) and distinguishes 26,549 of the 42,164 Swiss-Prot annotated isoforms (63%).<br>Data acquisition: The data was acquired using similar instruments, settings and mass analyzers. Specifically, an Orbitrap Fusion Lumos mass spectrometer coupled with a Dionex 3000 HPLC system was used for data acquisition.<br>Limitations of the training data: The model was trained on tryptic peptides from human origin. There is a possibility that additional liquid chromatography parameters not captured by iRT values may lead to suboptimal predictions.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model performs regression, predicting a continuous iRT value.<br>Limitations of the model: The model is limited by the type and conditions of chromatography used for retention time prediction. Within limits the predictions can be aligned to experimental values with a subset of the data.<br>**Evaluation**<br>Performance measures: Pearson correlation (R) and Δt95%, the time window required to encompass 95% of all peptides around the diagonal.<br>Choice of performance measures: Pearson correlation (R) is chosen to determine the linear correlation between predicted and experimental values. The Δt95% is chosen to quantify the deviation between the predicted and measured retention times and to indicate the time window in which 95% of peptides are found.<br>Single number for performance: When reporting a single number for performance, the R value is used, which represents the linear correlation between predicted and measured values.<br>Comparison to SOTA: No model was predicting citrullinated peptides at the time.<br>Evaluation method: The model was evaluated using a holdout set and cross-validation. The data was split into three parts: one for training, a test set to control for overfitting, and a holdout set to estimate performance. The model was also evaluated on an independent dataset and showed improved accuracy by transfer learning.<br>Independent data: The model has been evaluated on independent data acquired Mergner et al. and Wang et al.<br>Data applicability: The model is applicable to  both tryptic and non-tryptic un-modified and citrullinated peptides.<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]) as well as Citrullination/Deamidation (`R[UNIMOD:7]`, `Q[UNIMOD:7]`, `N[UNIMOD:7]`). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>Valid Precursor Charges are 1 to 6.<br>There are no limitations to valid Collision energies.<br>Valid fragmentation types are `HCD` and `CID`.<br>**Output notes**<br>Intensity was normalized to the highest predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1-3. A maks is applied for impossible peaks (i.e. exceeding peptide length, or precursor charge).<br>

        ### Citation
        Not available yet.<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25]) 
            inputs['fragmentation_types'] = np.array(["HCD", "CID"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2024_intensity_cit", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_cit/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                        {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_cit/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)),
                    list("name"= "fragmentation_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("HCD", "CID")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2024_intensity_cit",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)),
                list("fragmentation_types" = c("HCD", "CID")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_cit/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                                {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["HCD", "CID"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_intensity_cit/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAR[UNIMOD:7]AAAKAK\", \"AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]},");
                    jsonInputStringBuilder.append("{\"name\": \"fragmentation_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"HCD\", \"CID\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2024_intensity_cit
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2024_intensity_cit_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2024_irt_PTMs_gl/infer:
     post:
      tags:
        - Retention Time
      summary: Prosit_2024_irt_PTMs_gl
      description: |
        ### Summary
        PTM-Model for ProSIMSIt<br>

        ### Citation
        

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2024_irt_PTMs_gl", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_PTMs_gl/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_PTMs_gl/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2024_irt_PTMs_gl",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_PTMs_gl/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_PTMs_gl/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"[UNIMOD:737]-AAAAAKAK[UNIMOD:737]\", \"[UNIMOD:737]-AAAAY[UNIMOD:21]AR\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2024_irt_PTMs_gl
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2024_irt_PTMs_gl_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2024_irt_cit/infer:
     post:
      tags:
        - Retention Time
      summary: Prosit_2024_irt_cit
      description: |
        ### Summary
        **Data**<br>Source of the data: The model was trained using data from the ProteomeTools project.  This included previously published unmodified tryptic/non-tryptic peptides and data generated specifically for this study with citrullinated tryptic/non-tryptic peptides. The data consisted of tandem mass spectra acquired from synthetic peptides. This project synthesized and analyzed over 650,000 tryptic and non-tryptic peptides using multi-modal LC-MS/MS.<br>Type of molecules: The training data included tryptic peptides, as well as non-tryptic peptides representing HLA class I & II ligands and products of the proteases AspN and LysN. Citrullinated tryptic/non-tryptic peptides were also included.<br>Representation of molecular complexity: The training data was designed to represent a wide variety of peptide sequences and fragmentation patterns, including both tryptic and non-tryptic unmodified and citrullinated peptides. The data included a large number of peptides with different amino acid combinations, covering nearly all possible N- and C-terminal amino acid combinations. This was done to address the challenge of identifying non-tryptic HLA peptides, whose fragmentation characteristics can be distinct from tryptic peptides.<br>Data acquisition: The data was acquired using one instrument (Orbitrap Fusion Lumos), with six different collision energies (20, 23, 25, 28, 30, 35) and on two different Mass analyzers Fourier transform mass analyzer (FTMS) and ion trap mass analyzer (ITMS).<br>Limitations of the training data: The model was not trained on peptides containing free cysteine side chains or other amino acid modifications that may be identified on HLA peptides. Also, the data had very few non-tryptic citrullinated peptides.<br>False positives/negatives: The training data was filtered for 1% FDR.<br>**Optimization**<br>Optimization target: y and b fragment ion intensities with charge 1-3<br>Experimental variability: No comparison with experimental variability is published.<br>Metric: Spectral angle (SA) was used to compare predicted and experimental spectra.<br>**Model**<br>Interpretability: The model is a black box, However, the model is split into an encoder and a decoder, which means the model learns an intermediate latent space to represent peptide sequences and parameters which is then used to make predictions.<br>Model type: The model is a regression model, predicting continuous values for fragment ion intensities.<br>Limitations: The model is trained on two fragmentation techniques (HCD and CID), mass analyzers (Orbitrap and Iontrap), and collision energies (20, 23, 25, 30, 35). It interpoaltes well in this range of collision energies but has not been evaluated far outside this range. It has not been evaluated under different conditions or with different instruments or fragmentation techniques.<br>**Evaluation**<br>Performance measures: The performance measures reported include Pearson correlation (R) and normalized spectral angle (SA).<br>Choice of performance measures: SA was chosen because spectral angle is more sensitive as a similarity measure.<br>Single number performance: The spectral angle was used to provide an overall measure of performance, but the distribution of spectral angle values was also examined to assess the model's performance across different types of peptides and conditions.<br>Comparison to SOTA: No model was predicting citrullinated peptides at the time.<br>Evaluation methods: The model was evaluated using cross-validation (training, testing, and holdout sets), and on independent datasets (re-analyzing data from other publications). <br>Independent data: The model has been evaluated on independent data acquired Mergner et al. and Wang et al.<br>Model performance variability: The model's performance is not highly variable. The model shows consistent performance across different collision energies, peptides, and datasets. The model’s predictions can be calibrated to the NCE used for acquisition.<br>Data applicability: The model is applicable to both tryptic and non-tryptic un-modified and citrullinated peptides. It is applicable to data acquired using HCD and CID fragmentation. It is not applicable to data acquired using other fragmentation methods or using different mass analyzers. (e.g. TOF analyzer)<br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported modifications are cysteine carbamidomethylation (C[UNIMOD:4]) and methionine oxidation (M[UNIMOD:35]) as well as Citrullination/Deamidation (`R[UNIMOD:7]`, `Q[UNIMOD:7]`, `N[UNIMOD:7]`). Cysteine residues should be carbamidomethylated (C[UNIMOD:4]).<br>**Output notes**<br>The model outputs indexed retention time. As index a subset of PROCAL peptides were used.<br>

        ### Citation
        Not available yet.<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAR[UNIMOD:7]K"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2024_irt_cit", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_cit/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAR[UNIMOD:7]K"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_cit/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(1,1), "datatype"= "BYTES", "data"= c("AAAAAKAR[UNIMOD:7]K")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2024_irt_cit",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAR[UNIMOD:7]K")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_cit/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [1,1], "datatype": "BYTES", "data": ["AAAAAKAR[UNIMOD:7]K"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2024_irt_cit/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [1,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAR[UNIMOD:7]K\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2024_irt_cit
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2024_irt_cit_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /Prosit_2025_intensity_MultiFrag/infer:
     post:
      tags:
        - Fragment intensity
      summary: Prosit_2025_intensity_MultiFrag
      description: |
        ### Summary
        **General**<br>Prosit_2025_intensity_MultiFrag is a Prosit model trained jointly on 5 different types of fragmentation spectra -> HCD, ECD, EID, UVPD, and ETciD. The model outputs 815 ion types, which include ion series a, a+proton, b, c, c+proton, x, x+proton, y, z, z+proton, up to length 29 and product charge +3. <br><br>**Data**<br>The model was trained on ~2.1 million unique PSMs, obtained through MSFragger searches, roughly equally divided between the 5 fragmentation types. Each fragmentation type was run on digests using 5 different enzymes: LysN, LysC, GluC, Trypsin, and Chymotrypsin. The instrument used was an Orbitrap Exploris (Thermo Fisher Scientific) equipped with an Omnitrap (Fasmatech). The raw files were provided by Dr. Shabaz Mohammed of The University of Oxford, Oxford, England.<br><br>**Optimization**<br>The model was trained on the masked spectral distance loss function, desinged to minimize the spectral angle between model predictions and target spectra.<br><br>**Model**<br>The model's architecture is a recurrent neural network equipped with GRU cell memory units. The architecture is similar to Prosit, with modifications to accomodate the unstructured output space of 815 ions. Predicted ions are chosen the basis of frequency, retaining only the ions that were annotated at least 100 times throughout the entire dataset.<br><br>**Evaluation**<br>The model was evaluated on its loss function, as well as the Pearson correlation between predictions and targets.<br><br>**Input notes**<br>The maximum allowed peptide length is 30. The allowed modifications are N-terminal acetylation ([UNIMOD:1]) and Oxidation ([UNIMOD:35]). Carbamidomethylation is fixed on Cysteine. You must always include its Unimod code, in a peptide sequence with cysteine -> C[UNIMOD:4].<br>Valid precursor charges are 1 through 6.<br>The fragmentation types are input as strings ("HCD", "ECD", "EID", "UVPD", "ETciD").<br><br>**Output notes**<br>Prosit_2025_intensity_MultiFrag outputs all 815 ion intensities, their string annotations, and the ions' m/z's, with impossible ions (too long or too high fragment charge) having m/z=-1.0.<br>

        ### Citation
        

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR"]) 
            inputs['precursor_charges'] = np.array([2, 2]) 
            inputs['fragmentation_types'] = np.array(["UVPD", "HCD"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("Prosit_2025_intensity_MultiFrag", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/Prosit_2025_intensity_MultiFrag/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 2]},
                        {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["UVPD", "HCD"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/Prosit_2025_intensity_MultiFrag/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 2)),
                    list("name"= "fragmentation_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("UVPD", "HCD")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "Prosit_2025_intensity_MultiFrag",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR")),
                list("precursor_charges" = c(2, 2)),
                list("fragmentation_types" = c("UVPD", "HCD")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/Prosit_2025_intensity_MultiFrag/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 2]},
                                {"name": "fragmentation_types", "shape": [2,1], "datatype": "BYTES", "data": ["UVPD", "HCD"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/Prosit_2025_intensity_MultiFrag/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"NATTRQVETELFPC[UNIMOD:4]L\", \"M[UNIMOD:35]IDLSGNPVLR\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 2]},");
                    jsonInputStringBuilder.append("{\"name\": \"fragmentation_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"UVPD\", \"HCD\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: Prosit_2025_intensity_MultiFrag
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prosit_2025_intensity_MultiFrag_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /UniSpec/infer:
     post:
      tags:
        - Fragment intensity
      summary: UniSpec
      description: |
        ### Summary
        Unispec is a model trained to predict full HCD mass spectra intensities, containing nearly 8000 different ion types in its output space, including a, b, y ion series, precursors peaks, immonium ions, and other fragmentation, 21 neutral losses, up to 5 isotopes, and internal ions. The Koina version automatically outputs the 200 highest intensities from the prediction while setting any unfeasible ions (given the sequence, charge, and modifications) to have -1 intensity. <br>Peptide sequences are submitted as modified sequences, with modifications immediately following the 1-letter AA where they are located. Modifications are represented with the word UNIMOD followed by a colon and the modification's Unimod ID, e.g., AGM[UNIMOD:35]MGAK. The model was trained for 7 modifications, listed below with their Unimod IDs. The maximum length for peptides can be up to 40 amino acids and a maximum charge of 8.<br><table><tr><th>Unimod-ID</th><th>Modification</th></tr><tr><td>1</td><td>Acetyl</td></tr><tr><td>4</td><td>Carbamidomethyl</td></tr><tr><td>28</td><td>Gln->pyro-Glu</td></tr><tr><td>27</td><td>Glu->pyro-Glu</td></tr><tr><td>35</td><td>Oxidation</td></tr><tr><td>21</td><td>Phospho</td></tr><tr><td>26</td><td>Pyro-carbamidomethyl</td></tr></table><br>The PyTorch model was trained on collision energy data in units of eV.  The Koina version is set up for the user to submit collision energy in NCE  and the instrument type. It will convert this NCE value to the corresponding eV value depending on the instrument type.<br><table><tr><th>Code</th><th>Name</th></tr><tr><td>QE</td><td>Q Exactive</td></tr><tr><td>QEHFX</td><td>Q Exactive HF-X</td></tr><tr><td>LUMOS</td><td>Orbitrap Fusion Lumos</td></tr><tr><td>ELITE</td><td>Orbitrap Elite</td></tr><tr><td>VELOS</td><td>Orbitrap Velos</td></tr><tr><td>NONE</td><td>Use input without adjustment</td></tr></table><br>Note, instruments QE, QEHFX, and ELITE only work for charges 2-5; VELOS only works for charges 2-4. If you must predict charges outside these ranges for these instruments, just set the instrument to NONE. This  means the collision energy you enter is used directly as input to the model, i.e. no NCE->eV conversion.<br>**Input notes**<br>**Output notes**<br>Fragment ion annotation differs slightly from other models because significantly more fragment ions are annotated. A full description can be found in [a supplemental xlsx file](https://pubs.acs.org/doi/suppl/10.1021/acs.analchem.3c02321/suppl_file/ac3c02321_si_003.xlsx). There are six ion categories a, b, y, precursor (p), immonium & residue fragment ions (see Table S2c), internal (Int). There are 23 unique, observed neutral losses (see Table S2b) which can occour on all ion series except a ions. The pattern "^[2-3]" denotes the charge state of the fragment ion, for charge one this is omitted. For example "^2" denotes a fragment ion with charge +2. The pattern "+[1-5]i" denotes the isotopic peak. For example "+3i" denotes the third isotopic peak. If this is omitted the monoisotopic fragment ion is annotated. The Internal ion notation follow the pattern "Int[x]>[y]" where x is a number denoting the start position within peptide and y is a number denoting the number of amino acid residues included in the fragmen ion.<br>

        ### Citation
        UniSpec: Deep Learning for Predicting the Full Range of Peptide Fragment Ion Series to Enhance the Proteomics Data Analysis Workflow<br>Lapin, J., Yan X., Dong, Q. (2024) <br>Anal Chem. https://doi.org/10.1021/acs.analchem.3c02321<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK"]) 
            inputs['precursor_charges'] = np.array([1,2]) 
            inputs['collision_energies'] = np.array([25, 25]) 
            inputs['instrument_types'] = np.array(["LUMOS", "QE"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("UniSpec", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/UniSpec/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                        {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                        {"name": "instrument_types", "shape": [2,1], "datatype": "BYTES", "data": ["LUMOS", "QE"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/UniSpec/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(1,2)),
                    list("name"= "collision_energies", "shape"= c(2,1), "datatype"= "FP32", "data"= c(25, 25)),
                    list("name"= "instrument_types", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("LUMOS", "QE")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "UniSpec",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK")),
                list("precursor_charges" = c(1,2)),
                list("collision_energies" = c(25, 25)),
                list("instrument_types" = c("LUMOS", "QE")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/UniSpec/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [1,2]},
                                {"name": "collision_energies", "shape": [2,1], "datatype": "FP32", "data": [25, 25]},
                                {"name": "instrument_types", "shape": [2,1], "datatype": "BYTES", "data": ["LUMOS", "QE"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/UniSpec/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"YYHTLFTHSLPK\", \"AGC[UNIMOD:4]FS[UNIMOD:27]PK\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [1,2]},");
                    jsonInputStringBuilder.append("{\"name\": \"collision_energies\", \"shape\": [2,1], \"datatype\": \"FP32\", \"data\": [25, 25]},");
                    jsonInputStringBuilder.append("{\"name\": \"instrument_types\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"LUMOS\", \"QE\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: UniSpec
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UniSpec_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_CID_TMT/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_CID_TMT
      description: |
        ### Summary
        This model was trained on observed spectrum intensities from 72,138 unique TMT-labeled peptides. MS2 spectra were acquired in the ion trap with CID fragmentation (trap-type CID). <br>Raw train/test and evaluation data are available via PRIDE, with the identifiers PXD041002 and PXD005890, respectively. Processed data is available at https://doi.org/10.5281/zenodo.7833635.<br>Modifications on the input peptide are only considered for the MS2 peak m/z values. Prediction accuracy for peptides with other modifications may vary and should be evaluated on a case-by-case basis. Predicted intensities will always assume TMT labeling, regardless of the input modification state.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br><br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_CID_TMT", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_CID_TMT/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_CID_TMT/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_CID_TMT",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_CID_TMT/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_CID_TMT/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_CID_TMT
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_CID_TMT_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_HCD2021/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_HCD2021
      description: |
        ### Summary
        This model was trained on observed spectrum intensities from six projects, all using HCD (beam-type CID) fragmentation and Orbitrap acquisition. These projects contain immunopeptides (PXD012308, PXD006939, PXD009925, PXD000394, and PXD004894), and peptides from a chymotrypsin digest (PXD010154). <br>The model was evaluated on four distinct datasets with HLA-I immunopeptides (PXD005231), HLA-II immunopeptides (PXD020011), chymotrypsin peptides (PXD010154), and trypsin peptides (PXD008034), respectively.<br>The modification state is not considered for intensity predictions, only for the m/z values of the MS2 peaks. <br>The model was trained on peptides with oxidation of methionine and fixed or variable carbamidomethylation of cysteine. Prediction accuracy for peptides with other modifications may vary and should be evaluated on a case-by-case basis.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br><br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_HCD2021", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_HCD2021/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_HCD2021/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_HCD2021",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_HCD2021/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_HCD2021/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_HCD2021
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_HCD2021_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_Immuno_HCD/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_Immuno_HCD
      description: |
        ### Summary
        This model was trained on observed spectrum intensities from five projects, all using HCD (beam-type CID) fragmentation and Orbitrap acquisition of immunopeptides (PXD012308, PXD006939, PXD009925, and PXD000394). <br>The model was evaluated on four distinct datasets with HLA-I immunopeptides (PXD005231), HLA-II immunopeptides (PXD020011), chymotrypsin peptides (PXD010154), and trypsin peptides (PXD008034), respectively.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br><br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_Immuno_HCD", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_Immuno_HCD/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_Immuno_HCD/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_Immuno_HCD",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_Immuno_HCD/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_Immuno_HCD/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_Immuno_HCD
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_Immuno_HCD_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_TTOF5600/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_TTOF5600
      description: |
        ### Summary
        This model was trained on 215 713 unique peptides acquired on a TripleTOF 5600+ mass spectrometer in beam-type CID mode (PXD000954). <br>It was evaluated on 15 111 unique peptides from PXD001587.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_TTOF5600", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_TTOF5600/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_TTOF5600/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_TTOF5600",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_TTOF5600/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_TTOF5600/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_TTOF5600
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_TTOF5600_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_iTRAQphospho/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_iTRAQphospho
      description: |
        ### Summary
        This model was trained on 183 383 unique peptides from the NIST "Human Orbitrap - HCD iTRAQ-4 Phospho" spectral library. <br>It was evaluated on 9088 unique peptides from PXD001189.<br>Predicted intensities will always assume iTRAQ labeling and phosphorylations, regardless of the input modification state. Prediction accuracy for peptides with other modifications may vary and should be evaluated on a case-by-case basis.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br><br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_iTRAQphospho", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_iTRAQphospho/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_iTRAQphospho/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_iTRAQphospho",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_iTRAQphospho/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_iTRAQphospho/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_iTRAQphospho
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_iTRAQphospho_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_timsTOF2023/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_timsTOF2023
      description: |
        ### Summary
        The peak intensity models were trained using timsTOF data from two different labs. <br>This dataset includes peptides from JY (trypsin and elastase digests) and HeLa (trypsin digests), as well as HLA class I immunoprecipitation-enriched peptides from JY, HeLa, SK-MEL-37, and HL60 samples, with multiple collision energy settings applied.<br>In total, 251,149 unique peptidoforms, considering sequence, charge, and modifications, were used for model training, ensuring comprehensive coverage of various peptide types. <br>For each unique peptidoform, the highest-scoring PSM was retained for training, while 10,045 peptides were set aside for evaluation purposes.<br>The data used for model training can be accessed through the following dataset identifiers. <br>Data from JY immunopeptidomics used for training can be accessed with the dataset identifiers PXD043026 for ProteomeXchange and JPST002158 for jPOST. Data from the Carapito lab have been deposited to the ProteomeXchange repositories PXD046535 for HL60 immunopeptidomics and PXD046543 for HeLa tryptic proteomics files.<br>This model can be applied to tryptic, elastase, and HLA class I immunopeptide spectra acquired on timsTOF instruments.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_timsTOF2023", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2023/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2023/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_timsTOF2023",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2023/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2023/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_timsTOF2023
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_timsTOF2023_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /ms2pip_timsTOF2024/infer:
     post:
      tags:
        - Fragment intensity
      summary: ms2pip_timsTOF2024
      description: |
        ### Summary
        The training data for this model builds upon the set from the timsTOF 2023 model. <br>It includes  trypsin, elastase, and class I immunopeptide data (PXD046535 and PXD040385), expanded with class II immunopeptides from Hoenisch Gravel et al. (PXD038782). <br>A total of 505,289 highest-scoring peptidoforms were selected across all datasets, accounting for precursor charge as part of the peptidoform. <br>These peptidoforms were then divided into a training set (480,024 peptidoforms) and a test set (25,265 peptidoforms) using a stratified split based on dataset origin to ensure balanced representation of class I, class II, trypsin-digested, and elastase-digested peptides in both subsets. <br>All processed data is publicly available on Zenodo at <a href="https://doi.org/10.5281/zenodo.11277943">10.5281/zenodo.11277943</a>.<br>Find out more about this model <a href="https://github.com/compomics/ms2pip">here</a>.<br><br>**Input notes**<br>All modifcations need to be explicitly encoded in the sequence. Valid sequences lengths are up to 30 AA. Supported are all modification from UNIMOD but modifications are only used to shift fragment mz they do not affect intensity.<br>There are no limitations to valid Precursor Charges.<br>**Output notes**<br>Intensity was normalized to the sum of predicted intensity value.<br>The model predicts y and b ions index 1-30 and charge 1. A maks is applied for impossible peaks (i.e. exceeding peptide length).<br>

        ### Citation
        Updated MS²PIP web server supports cutting-edge proteomics applications.<br>Declercq, A., Bouwmeester, R., Chiva, C., Sabidó, E., Hirschler, et al.<br>Nucleic Acids Research doi:10.1093/nar/gkad335<br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["ACDEK", "AAAAAAAAAAAAA"]) 
            inputs['precursor_charges'] = np.array([2, 3])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("ms2pip_timsTOF2024", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2024/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                        {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2024/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("ACDEK", "AAAAAAAAAAAAA")),
                    list("name"= "precursor_charges", "shape"= c(2,1), "datatype"= "INT32", "data"= c(2, 3)))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "ms2pip_timsTOF2024",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("ACDEK", "AAAAAAAAAAAAA")),
                list("precursor_charges" = c(2, 3)))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2024/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["ACDEK", "AAAAAAAAAAAAA"]},
                                {"name": "precursor_charges", "shape": [2,1], "datatype": "INT32", "data": [2, 3]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/ms2pip_timsTOF2024/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"ACDEK\", \"AAAAAAAAAAAAA\"]},");
                    jsonInputStringBuilder.append("{\"name\": \"precursor_charges\", \"shape\": [2,1], \"datatype\": \"INT32\", \"data\": [2, 3]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: ms2pip_timsTOF2024
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ms2pip_timsTOF2024_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

  /pfly_2024_fine_tuned/infer:
     post:
      tags:
        - Flyability
      summary: pfly_2024_fine_tuned
      description: |
        ### Summary
        Find out more about this model in the respective preprint.<br><br>**Data**<br>Source of the data: The Pfly model was initially trained on peptide data from the ProteomeTools dataset, extracted from the PRIDE repository under the identifiers PXD004732, PXD010595, and PXD021013, along with supplementary material from corresponding publications. The dataset includes over 1 million unique synthetic peptide sequences derived from the human proteome. To mitigate a potential bias toward peptide synthesizability, the model was fine-tuned using biological data from the ProteomeXchange repository (PXD024364), which contains bottom-up proteomics data from six human cell lines (GM12878, HeLa S3, HepG2, hES1, HUVEC, and K562), fractionated into 24-80 fractions and analyzed using three fragmentation methods (HCD, CAD, and ETD).<br>Representation of complexity:  Initially, the model was trained on synthetic peptides, which ensured high consistency but lacked the full complexity of biological samples. Fine-tuning with enzymatically digested proteomes from different cell lines introduced greater variability in protein abundance, digestion efficiency, and fragmentation patterns, making the model more generalizable.<br>Data acquisition: The ProteomeTools dataset offers homogeneous experimental conditions, ensuring a controlled learning environment. The fine-tuning dataset, however, introduces additional variability due to different cell lines, proteases, and fragmentation techniques, reflecting the conditions seen in real biological experiments.<br>Limitations of the training data: The initial dataset used for training consisted of synthetic peptides, which provided a controlled and consistent learning environment. However, this introduced a bias toward peptides that are easier to synthesize, potentially limiting the model's ability to generalize to biological samples. To address this, the model was fine-tuned on proteomics data from multiple human cell lines, which introduced additional variability in protein abundance, digestion efficiency, and fragmentation patterns. Despite this improvement, the model remains dependent on the experimental conditions under which the training data was acquired. Differences in chromatography settings, mass spectrometry instruments, and sample preparation methods may impact its ability to generalize across all proteomics experiments.<br>False positives/negatives: False positive predictions may arise due to peptides being classified as detectable when, in reality, factors such as co-elution, ion suppression, or misidentifications in MS analysis prevent their detection. Conversely, false negatives occur when peptides are predicted to be undetectable but are experimentally observed, often due to variations in protein abundance or differences in enzymatic digestion. The initial training dataset included rigorous filtering steps to remove low-confidence identifications, but misclassified peptides in biological data remain a challenge. To further refine the model, a rescoring strategy using the Oktoberfest pipeline was employed, demonstrating that a portion of previously misclassified non-flyers were indeed detectable peptides that had been missed during standard MS data processing.<br><br>**Optimization**<br>Optimization target: The model predicts peptide detectability, classifying peptides into flyers (detectable) and non-flyers (undetectable). The fine-tuning step further refines classification by incorporating peptide detectability across different biological conditions.<br>Experimental variability: The fine-tuning process accounts for variability in peptide ionization, retention, and fragmentation, but protein abundance differences in the dataset may still impact predictions.<br>Metric: The study does not explicitly mention a specific spectral similarity metric but does incorporate MS1 intensity values and peptide detectability rates from experimental data.<br><br>**Model**<br>Interpretability: Pfly is a black-box deep learning model, though attention mechanisms help highlight important sequence features. Fine-tuning with biological data may provide a more realistic feature representation compared to synthetic data.<br>Model type: The model is multi-class (weak, intermediate, and strong flyers).<br>Limitations: Bias towards synthesizability was reduced but may still exist. The model's accuracy depends on experimental conditions, chromatography settings, and MS instrument parameters. Peptide detectability may be influenced by protein abundance rather than intrinsic sequence properties.<br><br>**Evaluation**<br>Performance measures: Reported metrics include binary accuracy (94%), Matthews correlation coefficient (0.85), precision (96%), recall (97%), F1 score (96%), and AUC (0.97).<br>Confusion matrix: confusion matrices and ROC curves are provided. The fine-tuning dataset helped refine classification boundaries.<br>Comparision to baseline methods: Pfly was benchmarked against PepFormer, DeepMSPeptide, and DeepDetect, outperforming them in both synthetic and biological datasets.<br>Data applicability: The model is optimized for tryptic peptides in LC-ESI-MS experiments but may generalize to other settings with fine-tuning.<br><br>If you use predictions generated by this model please cite the preprint.<br>

        ### Citation
        To fly, or not to fly, that is the question: A deep learning model for peptide detectability prediction in mass spectrometry.<br>Abdul-Khalek, N. et al.<br>bioRxiv, pp.2024-10 (2024). https://doi.org/10.1101/2024.10.28.620610 <br>

      x-code-samples:
        - lang: Python
          label: 'Python (koinapy)'
          source: |
          
            # If you get a ModuleNotFound error install koinapy with `pip install koinapy`.
            from koinapy import Koina
            import numpy as np
            import pandas as pd
            
            # koinapy only takes the input it requires for the current model.
            # if you want to compare multiple models you can use a dataframe wit all columns at the same time.
            inputs = pd.DataFrame()  
            inputs['peptide_sequences'] = np.array(["AAAAAKAK", "AAAAAKAK"])
            
            
            # If you are unsure what inputs your model requires run `model.model_inputs`
            model = Koina("pfly_2024_fine_tuned", "koina.wilhelmlab.org:443")
            predictions = model.predict(inputs)
        - lang: Shell
          label: 'cURL'
          source: |
          
            curl "https://koina.wilhelmlab.org:443/v2/models/pfly_2024_fine_tuned/infer" \
                -d '{
                    "id": "0", "inputs": [
                        {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]}]
                    }'
        - lang: Shell
          label: 'R-lang (http)'
          source: |
          
            library(httr)
            library(jsonlite)
            
            # Define the URL
            url <- "https://koina.wilhelmlab.org:443/v2/models/pfly_2024_fine_tuned/infer"
            
            # Define the JSON payload
            payload <- toJSON(
              list(
                "id" = "0",
                "inputs" = list(
                    list("name"= "peptide_sequences", "shape"= c(2,1), "datatype"= "BYTES", "data"= c("AAAAAKAK", "AAAAAKAK")))
              ),
              auto_unbox = TRUE
            )
            
            # Send the HTTP POST request
            response <- httr::POST(url, body = payload, encode = "json")
            
            # Check if the request was successful
            if (httr::http_status(response)$category == "Success") {
              print("Request was successful!")
              predictions = httr::content(response)
            } else {
              cat("Request failed with status code:", httr::http_status(response)$code, "\n")
            }
            
            for(x in predictions$outputs){
              print(x$name)
              print(unlist(x$data))
            }
        - lang: Shell
          label: 'R-lang (koinar)'
          source: |
          
            model <- koinar::Koina$new(model_name = "pfly_2024_fine_tuned",
                                       server_url = "koina.wilhelmlab.org:443",
                                       ssl = TRUE)
            
            input_data <- list(
                list("peptide_sequences" = c("AAAAAKAK", "AAAAAKAK")))
            
            df_input = data.frame(input_data)
            predictions = model$predict(df_input)
            predictions
        - lang: java
          label: 'java (Version > 15)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class CurlRequestSender {
            
                public static void sendPostRequest() {
                    String requestUrl = "https://koina.wilhelmlab.org:443/v2/models/pfly_2024_fine_tuned/infer";
                    String jsonInputString = """
                        {
                            "id": "0", "inputs": [
                                {"name": "peptide_sequences", "shape": [2,1], "datatype": "BYTES", "data": ["AAAAAKAK", "AAAAAKAK"]}
                            ]
                        }""";
            
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }
        - lang: java
          label: 'java (Version > 8)'
          source: |
          
            import java.io.BufferedReader;
            import java.io.InputStreamReader;
            import java.io.OutputStream;
            import java.net.URL;
            import javax.net.ssl.HttpsURLConnection;
            
            public class KoinaRequest {
            
                public static void sendPostRequest() {
                    String requestUrl =  "https://koina.wilhelmlab.org:443/v2/models/pfly_2024_fine_tuned/infer";
                    StringBuilder jsonInputStringBuilder = new StringBuilder();
                    jsonInputStringBuilder.append("{\"id\": \"0\", \"inputs\": [");
                    jsonInputStringBuilder.append("{\"name\": \"peptide_sequences\", \"shape\": [2,1], \"datatype\": \"BYTES\", \"data\": [\"AAAAAKAK\", \"AAAAAKAK\"]}");
                    jsonInputStringBuilder.append("]}");
                    String jsonInputString = jsonInputStringBuilder.toString();
                    try {
                        URL url = new URL(requestUrl);
                        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
                        connection.setRequestMethod("POST");
                        connection.setRequestProperty("Content-Type", "application/json; utf-8");
                        connection.setDoOutput(true);
            
                        try (OutputStream os = connection.getOutputStream()) {
                            byte[] input = jsonInputString.getBytes("utf-8");
                            os.write(input, 0, input.length);
                        }
            
                        int responseCode = connection.getResponseCode();
                        System.out.println("Response Code: " + responseCode);
            
                        if (responseCode == HttpsURLConnection.HTTP_OK) { // success
                            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                            String inputLine;
                            StringBuffer response = new StringBuffer();
            
                            while ((inputLine = in.readLine()) != null) {
                                response.append(inputLine);
                            }
                            in.close();
            
                            // print result
                            System.out.println("Response: " + response.toString());
                        } else {
                            System.out.println("Request failed.");
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            
                public static void main(String[] args) {
                    sendPostRequest();
                }
            }

      operationId: pfly_2024_fine_tuned
      requestBody:
        description: Body
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/pfly_2024_fine_tuned_input'
        required: true
      responses:
        '200':
          description: Successful operation
        '405':
          description: Invalid input

components:
  schemas:
    parameters:
      type: object
      properties:
        sequence_id:
          type: integer
          example: 0
        sequence_start:
          type: boolean
          example: false
        sequence_end:
          type: boolean
          example: false

    3dmolms_orbitrap_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: smiles
              shape: [1,1]
              datatype: BYTES
              data: ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]
            
            - name: precursor_types
              shape: [1,1]
              datatype: BYTES
              data: ["[M+H]+"]
            
            - name: collision_energies
              shape: [1,1]
              datatype: FP32
              data: [20]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/3dmolms_orbitrap_input_smiles"
              
              - $ref: "#/components/schemas/3dmolms_orbitrap_input_precursor_types"
              
              - $ref: "#/components/schemas/3dmolms_orbitrap_input_collision_energies"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    3dmolms_orbitrap_input_smiles:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]
          items:
            type: string
  
    3dmolms_orbitrap_input_precursor_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[M+H]+"]
          items:
            type: string
  
    3dmolms_orbitrap_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [20]
          items:
            type: number
  

    3dmolms_qtof_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: smiles
              shape: [1,1]
              datatype: BYTES
              data: ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]
            
            - name: precursor_types
              shape: [1,1]
              datatype: BYTES
              data: ["[M+H]+"]
            
            - name: collision_energies
              shape: [1,1]
              datatype: FP32
              data: [20]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/3dmolms_qtof_input_smiles"
              
              - $ref: "#/components/schemas/3dmolms_qtof_input_precursor_types"
              
              - $ref: "#/components/schemas/3dmolms_qtof_input_collision_energies"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    3dmolms_qtof_input_smiles:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["CN1C=NC2=C1C(=O)N(C(=O)N2C)C"]
          items:
            type: string
  
    3dmolms_qtof_input_precursor_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[M+H]+"]
          items:
            type: string
  
    3dmolms_qtof_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [20]
          items:
            type: number
  

    AlphaPeptDeep_ccs_generic_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2,2]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ccs_generic_input_peptide_sequences"
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ccs_generic_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    AlphaPeptDeep_ccs_generic_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
          items:
            type: string
  
    AlphaPeptDeep_ccs_generic_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2,2]
          items:
            type: number
  

    AlphaPeptDeep_ms2_generic_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
            - name: instrument_types
              shape: [2,1]
              datatype: BYTES
              data: ["QE", "QE"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ms2_generic_input_peptide_sequences"
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ms2_generic_input_precursor_charges"
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ms2_generic_input_collision_energies"
              
              - $ref: "#/components/schemas/AlphaPeptDeep_ms2_generic_input_instrument_types"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    AlphaPeptDeep_ms2_generic_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
          items:
            type: string
  
    AlphaPeptDeep_ms2_generic_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 2]
          items:
            type: number
  
    AlphaPeptDeep_ms2_generic_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  
    AlphaPeptDeep_ms2_generic_input_instrument_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["QE", "QE"]
          items:
            type: string
  

    AlphaPeptDeep_rt_generic_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/AlphaPeptDeep_rt_generic_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    AlphaPeptDeep_rt_generic_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM[UNIMOD:35]"]
          items:
            type: string
  

    Chronologer_RT_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [1,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Chronologer_RT_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Chronologer_RT_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]"]
          items:
            type: string
  

    Deeplc_hela_hf_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [4,1]
              datatype: BYTES
              data: ['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK']
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Deeplc_hela_hf_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Deeplc_hela_hf_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ['LGGNEQVTR', 'GAGSSEPVTGLDAK', 'VEATFGVDESNAK', 'LFLQFGAQGSPFLK']
          items:
            type: string
  

    IM2Deep_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2,2]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/IM2Deep_input_peptide_sequences"
              
              - $ref: "#/components/schemas/IM2Deep_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    IM2Deep_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]", "AAAAAKAKM"]
          items:
            type: string
  
    IM2Deep_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2,2]
          items:
            type: number
  

    Prosit_2019_intensity_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAK", "AAAAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2019_intensity_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2019_intensity_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2019_intensity_input_collision_energies"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    Prosit_2019_intensity_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAK", "AAAAAKAK"]
          items:
            type: string
  
    Prosit_2019_intensity_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2019_intensity_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  

    Prosit_2019_irt_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [1,1]
              datatype: BYTES
              data: ["AAAAAKAKM[UNIMOD:35]"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2019_irt_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Prosit_2019_irt_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAKM[UNIMOD:35]"]
          items:
            type: string
  

    Prosit_2020_intensity_CID_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAK", "AAAAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_CID_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_CID_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    Prosit_2020_intensity_CID_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAK", "AAAAAKAK"]
          items:
            type: string
  
    Prosit_2020_intensity_CID_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  

    Prosit_2020_intensity_HCD_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAK", "AAAAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_HCD_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_HCD_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_HCD_input_collision_energies"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    Prosit_2020_intensity_HCD_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAK", "AAAAAKAK"]
          items:
            type: string
  
    Prosit_2020_intensity_HCD_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2020_intensity_HCD_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  

    Prosit_2020_intensity_TMT_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
            - name: fragmentation_types
              shape: [2,1]
              datatype: BYTES
              data: ["HCD", "CID"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_TMT_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_TMT_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_TMT_input_collision_energies"
              
              - $ref: "#/components/schemas/Prosit_2020_intensity_TMT_input_fragmentation_types"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    Prosit_2020_intensity_TMT_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[UNIMOD:737]-AAAAAKAK", "[UNIMOD:737]-AAAAAKAK"]
          items:
            type: string
  
    Prosit_2020_intensity_TMT_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2020_intensity_TMT_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  
    Prosit_2020_intensity_TMT_input_fragmentation_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["HCD", "CID"]
          items:
            type: string
  

    Prosit_2020_irt_TMT_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [1,1]
              datatype: BYTES
              data: ["[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2020_irt_TMT_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Prosit_2020_irt_TMT_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[UNIMOD:737]-AAAAAKAKM[UNIMOD:35]"]
          items:
            type: string
  

    Prosit_2023_intensity_XL_CMS2_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences_1
              shape: [2,1]
              datatype: BYTES
              data: ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]
            
            - name: peptide_sequences_2
              shape: [2,1]
              datatype: BYTES
              data: ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [3,4]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [28, 28]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS2_input_peptide_sequences_1"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS2_input_peptide_sequences_2"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS2_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS2_input_collision_energies"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    Prosit_2023_intensity_XL_CMS2_input_peptide_sequences_1:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]
          items:
            type: string
  
    Prosit_2023_intensity_XL_CMS2_input_peptide_sequences_2:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]
          items:
            type: string
  
    Prosit_2023_intensity_XL_CMS2_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [3,4]
          items:
            type: number
  
    Prosit_2023_intensity_XL_CMS2_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [28, 28]
          items:
            type: number
  

    Prosit_2023_intensity_XL_CMS3_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS3_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_XL_CMS3_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    Prosit_2023_intensity_XL_CMS3_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["TQNVLGEK[UNIMOD:1881]GRR", "TQNVLGEK[UNIMOD:1881]GRR"]
          items:
            type: string
  
    Prosit_2023_intensity_XL_CMS3_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  

    Prosit_2023_intensity_timsTOF_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAK", "AAAAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_timsTOF_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_timsTOF_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2023_intensity_timsTOF_input_collision_energies"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    Prosit_2023_intensity_timsTOF_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAK", "AAAAAKAK"]
          items:
            type: string
  
    Prosit_2023_intensity_timsTOF_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2023_intensity_timsTOF_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  

    Prosit_2024_intensity_PTMs_gl_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
            - name: fragmentation_types
              shape: [2,1]
              datatype: BYTES
              data: ["HCD", "CID"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_PTMs_gl_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_PTMs_gl_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_PTMs_gl_input_collision_energies"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_PTMs_gl_input_fragmentation_types"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    Prosit_2024_intensity_PTMs_gl_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]
          items:
            type: string
  
    Prosit_2024_intensity_PTMs_gl_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2024_intensity_PTMs_gl_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  
    Prosit_2024_intensity_PTMs_gl_input_fragmentation_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["HCD", "CID"]
          items:
            type: string
  

    Prosit_2024_intensity_XL_NMS2_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences_1
              shape: [2,1]
              datatype: BYTES
              data: ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]
            
            - name: peptide_sequences_2
              shape: [2,1]
              datatype: BYTES
              data: ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [3,4]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [28, 28]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_XL_NMS2_input_peptide_sequences_1"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_XL_NMS2_input_peptide_sequences_2"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_XL_NMS2_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_XL_NMS2_input_collision_energies"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    Prosit_2024_intensity_XL_NMS2_input_peptide_sequences_1:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["DIADAVTAAGVEVAK[UNIMOD:1896]SEVR", "AGDQIQSGVDAAIK[UNIMOD:1896]PGNTLPMR"]
          items:
            type: string
  
    Prosit_2024_intensity_XL_NMS2_input_peptide_sequences_2:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["NFLVPQGK[UNIMOD:1896]AVPATK", "SANIALVLYK[UNIMOD:1896]DGER"]
          items:
            type: string
  
    Prosit_2024_intensity_XL_NMS2_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [3,4]
          items:
            type: number
  
    Prosit_2024_intensity_XL_NMS2_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [28, 28]
          items:
            type: number
  

    Prosit_2024_intensity_cit_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
            - name: fragmentation_types
              shape: [2,1]
              datatype: BYTES
              data: ["HCD", "CID"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_cit_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_cit_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_cit_input_collision_energies"
              
              - $ref: "#/components/schemas/Prosit_2024_intensity_cit_input_fragmentation_types"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    Prosit_2024_intensity_cit_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAR[UNIMOD:7]AAAKAK", "AQ[UNIMOD:7]AN[UNIMOD:7]AAAKAK"]
          items:
            type: string
  
    Prosit_2024_intensity_cit_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    Prosit_2024_intensity_cit_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  
    Prosit_2024_intensity_cit_input_fragmentation_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["HCD", "CID"]
          items:
            type: string
  

    Prosit_2024_irt_PTMs_gl_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2024_irt_PTMs_gl_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Prosit_2024_irt_PTMs_gl_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["[UNIMOD:737]-AAAAAKAK[UNIMOD:737]", "[UNIMOD:737]-AAAAY[UNIMOD:21]AR"]
          items:
            type: string
  

    Prosit_2024_irt_cit_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [1,1]
              datatype: BYTES
              data: ["AAAAAKAR[UNIMOD:7]K"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2024_irt_cit_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    Prosit_2024_irt_cit_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAR[UNIMOD:7]K"]
          items:
            type: string
  

    Prosit_2025_intensity_MultiFrag_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 2]
            
            - name: fragmentation_types
              shape: [2,1]
              datatype: BYTES
              data: ["UVPD", "HCD"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/Prosit_2025_intensity_MultiFrag_input_peptide_sequences"
              
              - $ref: "#/components/schemas/Prosit_2025_intensity_MultiFrag_input_precursor_charges"
              
              - $ref: "#/components/schemas/Prosit_2025_intensity_MultiFrag_input_fragmentation_types"
              
            minItems: 3
            maxItems: 3
            uniqueItems: true

  
    Prosit_2025_intensity_MultiFrag_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["NATTRQVETELFPC[UNIMOD:4]L", "M[UNIMOD:35]IDLSGNPVLR"]
          items:
            type: string
  
    Prosit_2025_intensity_MultiFrag_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 2]
          items:
            type: number
  
    Prosit_2025_intensity_MultiFrag_input_fragmentation_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["UVPD", "HCD"]
          items:
            type: string
  

    UniSpec_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [1,2]
            
            - name: collision_energies
              shape: [2,1]
              datatype: FP32
              data: [25, 25]
            
            - name: instrument_types
              shape: [2,1]
              datatype: BYTES
              data: ["LUMOS", "QE"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/UniSpec_input_peptide_sequences"
              
              - $ref: "#/components/schemas/UniSpec_input_precursor_charges"
              
              - $ref: "#/components/schemas/UniSpec_input_collision_energies"
              
              - $ref: "#/components/schemas/UniSpec_input_instrument_types"
              
            minItems: 4
            maxItems: 4
            uniqueItems: true

  
    UniSpec_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["YYHTLFTHSLPK", "AGC[UNIMOD:4]FS[UNIMOD:27]PK"]
          items:
            type: string
  
    UniSpec_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [1,2]
          items:
            type: number
  
    UniSpec_input_collision_energies:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [25, 25]
          items:
            type: number
  
    UniSpec_input_instrument_types:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["LUMOS", "QE"]
          items:
            type: string
  

    ms2pip_CID_TMT_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_CID_TMT_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_CID_TMT_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_CID_TMT_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_CID_TMT_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_HCD2021_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_HCD2021_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_HCD2021_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_HCD2021_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_HCD2021_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_Immuno_HCD_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_Immuno_HCD_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_Immuno_HCD_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_Immuno_HCD_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_Immuno_HCD_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_TTOF5600_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_TTOF5600_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_TTOF5600_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_TTOF5600_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_TTOF5600_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_iTRAQphospho_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_iTRAQphospho_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_iTRAQphospho_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_iTRAQphospho_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_iTRAQphospho_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_timsTOF2023_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_timsTOF2023_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_timsTOF2023_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_timsTOF2023_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_timsTOF2023_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    ms2pip_timsTOF2024_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["ACDEK", "AAAAAAAAAAAAA"]
            
            - name: precursor_charges
              shape: [2,1]
              datatype: INT32
              data: [2, 3]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/ms2pip_timsTOF2024_input_peptide_sequences"
              
              - $ref: "#/components/schemas/ms2pip_timsTOF2024_input_precursor_charges"
              
            minItems: 2
            maxItems: 2
            uniqueItems: true

  
    ms2pip_timsTOF2024_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["ACDEK", "AAAAAAAAAAAAA"]
          items:
            type: string
  
    ms2pip_timsTOF2024_input_precursor_charges:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: [2, 3]
          items:
            type: number
  

    pfly_2024_fine_tuned_input:
      type: object
      properties:
        id:
          type: string
          example: "0"
        inputs:
          example:
            
            - name: peptide_sequences
              shape: [2,1]
              datatype: BYTES
              data: ["AAAAAKAK", "AAAAAKAK"]
            
          type: array
          items:
            allOf:
              
              - $ref: "#/components/schemas/pfly_2024_fine_tuned_input_peptide_sequences"
              
            minItems: 1
            maxItems: 1
            uniqueItems: true

  
    pfly_2024_fine_tuned_input_peptide_sequences:
      type: object
      properties:
        name:
          type: string
        shape:
          type: array
          items:
            type: integer
        datatype:
          type: string
        data:
          type: array
          example: ["AAAAAKAK", "AAAAAKAK"]
          items:
            type: string
  
