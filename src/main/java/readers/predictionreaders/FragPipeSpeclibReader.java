package readers.predictionreaders;

import peptideptmformatting.PeptideFormatter;
import predictions.PredictionEntry;
import predictions.PredictionEntryHashMap;
import speclib.io.*;

import static peptideptmformatting.PTMhandler.setUnimodObo;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

//NOTE: this is the speclib format generated by SpeclibIO, converting from parquet format from transfer learning server
//this speclib format is read by DIA-NN
public class FragPipeSpeclibReader implements LibraryPredictionMapper {
    public List<String> filenames = new ArrayList<>();
    PredictionEntryHashMap allPreds = new PredictionEntryHashMap();

    public FragPipeSpeclibReader(String speclibFile) throws IOException {
        filenames.add(speclibFile);
        setUnimodObo();

        HashMap<Byte, String> iontypeMap = new HashMap<>();
        byte b = 1;
        byte y = 2;
        iontypeMap.put(b, "b");
        iontypeMap.put(y, "y");

        DiaNNSpecLibReader dslr = new DiaNNSpecLibReader(speclibFile);
        SpectralLibrary library = dslr.read();
        for (LibraryEntry entry : library.getEntries()) {
            Precursor target = entry.getTarget();
            String peptide = library.getPrecursors().get(target.getIndex());
            String charge = "";
            while(Character.isDigit(peptide.charAt(peptide.length() - 1))) {
                charge = peptide.charAt(peptide.length() - 1) + charge;
                peptide = peptide.substring(0, peptide.length() - 1);
            }
            PeptideFormatter pf = new PeptideFormatter(peptide, charge, "fragpipeSpeclib");

            List<Product> fragments = target.getFragments();
            int numFragments = fragments.size();
            float[] mzs = new float[numFragments];
            float[] intensities = new float[numFragments];
            int[] fragNums = new int[numFragments];
            int[] charges = new int[numFragments];
            String[] fragmentIonTypes = new String[numFragments];

            for (int i = 0; i < numFragments; i++) {
                Product fragment = fragments.get(i);
                mzs[i] = fragment.getMz();
                intensities[i] = fragment.getHeight();
                fragNums[i] = fragment.getIndex();
                charges[i] = fragment.getCharge();
                fragmentIonTypes[i] = iontypeMap.get(fragment.getType());
            }

            PredictionEntry pe = new PredictionEntry(mzs, intensities, fragNums, charges, fragmentIonTypes);
            pe.setRT(target.getiRT());
            pe.setIM(target.getiIM());
            allPreds.put(pf.getBaseCharge(), pe);
        }
    }

    @Override
    public PredictionEntryHashMap getPreds() throws IOException {
        return allPreds;
    }

    @Override
    public void setPreds(PredictionEntryHashMap preds) {
        allPreds = preds;
    }

    @Override
    public void clear() {
        allPreds.clear();
    }
}
